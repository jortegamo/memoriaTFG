\chapter{Diseño y desarrollo de la aplicación}
\section{Tipo de Arquitectura}
\paragraph{}
El modelo de arquitectura más habitual es el \textbf{MVC} (Modelo Vista Controlador) (figura \ref{fig:mvcpattern}). El modelo correspondería con la arquitectura de base de datos y el diseño de la misma, la vista son las interfaces o plantillas que se muestran al usuario y el controlador es el encargado de dotar a la aplicación de lógica y funcionalidad. Existen otros tipos de arquitectura tales como \textbf{MVVM} (figura \ref{fig:mvvmpattern}), donde el controlador del patrón MVC se sustituye por VM o \emph{ViewModel} que establece que cada vista posee lógica y un sistema de \emph{data-binding} entre plantillas.

\begin{figure}[htbp]
    \centering
    \subfigure[Patrón de arquitectura MVC]{
   	 \includegraphics[width=1\textwidth]{mvc.png}
    	\label{fig:mvcpattern}
    }
    \subfigure[Patrón de arquitectura MVVM]{
    	\includegraphics[width=1\textwidth]{mvvm.png}
	 \label{fig:mvvmpattern}
    }
    \caption{Patrones de arquitectura}
    \label{fig:patterns}
\end{figure}

\paragraph{}
La elección del patrón de arquitectura a usar es importante puesto que esa decisión nos limitará a la hora de usar determinadas herramientas.
\paragraph{}

\section{Búsqueda de herramientas}
\paragraph{}
Partiendo de los requisitos establecidos que caracterizarán la aplicación podemos afirmar que necesitamos encontrar herramientas que nos permitan construir una aplicación en tiempo real, realizar grabaciones de audio, una interfaz con UX (User eXperience) como parámetro fundamental y que trabaje de manera óptima.

\subsubsection{Aplicación en tiempo real y prototipado rápido}
\paragraph{}
Necesitamos algún framework o plataforma que trabaje con el concepto de reactividad o que lo simule. Elegimos MeteorJS por su flexibilidad, su asombroso concepto de reactividad y por su patrón de trabajo que engloba el desarrollo del cliente y del servidor. Debido a esta elección utilizaremos MongoDB como tecnología de base de datos y MVVM como patrón de arquitectura de la aplicación.
\paragraph{}
Para el enrutamiento es precisa otra herramienta que nos proporcione la funcionalidad de especificar a qué recurso pertenece una plantilla y que datos asociamos a ella. Para ello existen varios paquetes para Meteor que realizan este proceso como IronRouter o FlowRouter. Ambos igual de válidos pero para este proyecto se ha optado por IronRouter, ya que dispone de mayor documentación.
\paragraph{}
Para el concepto de publicaciones y subscripciones de Meteor usaremos publishComposite, un paquete que permite realizar publicaciones compuestas (varias colecciones con relación de dependencia reactiva) y que siguen manteniendo el principio de reactividad y optimizando nuestro sistema de subscripciones. Sin este paquete realizar esta labor es más compleja. 

\subsubsection{Grabaciones de audio}
\paragraph{}
Existen numerosas formas de grabar audio vía web y algunas API de sitios como SoundCloud incorporan un grabador de audio directamente. Aunque esta hubiera sido la vía más rápida, la verdad es que no habría sido la más flexible, ya que el hacerlo de esta manera requería que el uploading se efectuara en SoundCloud. Por este motivo se ha utilizado la tecnología de WebRTC para esta tarea y construido un grabador modular que puede incorporarse fácilmente a otros proyectos y que además si se desea usar el servicio de hosting de SoundCloud seguiría siendo factible. 

\subsubsection{Hosting o Almacenamiento}
\paragraph{}
Utilizaremos el servicio de hosting de SoundCloud para almacenar el audio de nuestras grabaciones. No es lo más sensato para una aplicación real y comercializable puesto que existen restricciones en lo que corresponde a capacidad, pero para nuestra aplicación es más que suficiente. 

\subsubsection{Interfaz con UX como parámetro de diseño fundamental}
\paragraph{}
Partiendo del requisito de que la aplicación debe ser atractiva al usuario y no sólo en términos visuales sino en eficacia a la hora de gestionar acciones, en este proyecto nos hemos decantado por el framework front-end Bootstrap para la maquetación y por la tecnología Flexbox para dotar de flexibilidad a las plantillas. Además utilizaremos SASS como preprocesador de CSS con el fin de optimizar nuestra arquitectura de estilos mediante un paquete para Meteor.


\section{Composición Inicial y entorno de desarrollo}
\paragraph{}
Una vez realizada la búsqueda de herramientas comenzamos a componer el entorno de nuestra aplicación. Para este proyecto utilizaremos el programa WebStorm de JetBrains. Incorpora herramientas de búsqueda y sustitución avanzada, terminal para comandos, integración con sistema de control de versiones Git y plugins que facilitan la labor de desarrollo como elmet.
\subsection{Primeros pasos}
\paragraph{}
Gracias al CLI de Meteor generamos nuestra aplicación mediante el comando: \emph{meteor create $<$AppName$>$}. Esto nos genera una carpeta con tres ficheros: index.html, index.js e index.css. En este momento ya tenemos nuestra aplicación Meteor creada. 
\paragraph{}
Ahora debemos estructurar nuestra aplicación según la jerarquía mostrada en la figura \ref{fig:hierarchyFolders} creando los ficheros y carpetas necesarios.

\paragraph{}
Una vez estructurada la aplicación instalamos los paquetes iniciales mediante el comando: \emph{meteor add $<$ PackageName$>$}. La lista de paquetes iniciales es la siguiente: 
\begin{itemize}
\item \textbf{accounts-base:} paquete base para cuentas de usuario.
\item \textbf{accounts-password:} contraseña como servicio de registro de usuarios.
\item \textbf{fortawesome:fontawesome:} biblioteca de iconos.
\item \textbf{fourseven:scss:} preprocesador Sass para estilos.
\item \textbf{iron:router:} paquete para enrutamiento.
\item \textbf{mizzao:bootstrap-3} maquetación.
\item \textbf{reywood:publish-composite:} publicaciones avanzadas y compuestas.
\end{itemize}

\subsection{Mixins}
\paragraph{}
SASS nos permite crear reglas dinámicas de estilos que poder incluir en cualquier clase llamados mixins. Para este proyecto hemos utilizado este concepto para la labor de cross-browsing. Esta labor se basa en la traducción de una misma regla a los distintos navegadores Web, ya que cada navegador interpreta algunas reglas de forma distinta. Por lo que estos mixins nos permiten unificar diferentes reglas que se interpretan de manera distinta dependiendo del navegador. Un ejemplo de mixin es el siguiente: 
\begin{lstlisting}[caption=Mixin border-radius, label={mixinEj}]
@mixin border-radius($radius){
	-webkit-border-radius: $radius;  #safari, chrome
	-moz-border-radius: $radius; #mozilla firefox
	-ms-border-radius: $radius; #Internet Explorer
	border-radius: $radius; #new
}
\end{lstlisting}
\paragraph{}
Creamos un fichero con el nombre de \_mixins.scss dentro de la carpeta client al nivel del fichero index.html. El carácter \_ indica al preprocesador que esta hoja de estilos no la debe procesar. El procesado lo realizará en el momento que la importemos a otra hoja de estilos e incluyamos algún mixin.
Los mixins más utilizados en este proyecto serán los siguientes: border-radius, flexbox (flex, flex-direction, flex-wrap, etc), opacity, transition, animation y gradient. El archivo está disponible en el repositorio de GitHub.
\section{Prototipo 1: Registro de usuarios y layout principal}
\paragraph{}
Este es el primer prototipo de la aplicación y se corresponde con el layout principal de la aplicación y con el registro de usuarios. 
\subsection{Layout principal}
\begin{figure}[htbp]
    \centering
    \subfigure[Large layout]{
   	 \includegraphics[scale=0.42]{layoutLarge.png}
    	\label{fig:layoutLg}
    }
    \subfigure[Small Layout]{
    	\includegraphics[scale=0.42]{layoutSmall.png}
	 \label{fig:layoutSm}
    }
    \caption{Diseño de Layout Full-responsive}
    \label{fig:layoutFR}
\end{figure}
Iron Router establece que el diseño de la aplicación debe realizarse en torno a dos plantillas: \{\{yield\}\} y \{\{layout\}\}. El layout es la plantilla genérica y el yield es el contenido. Como puede verse en la figura \ref{fig:layoutFR}, ésta va a ser la estructura genérica de nuestra aplicación: 
\begin{itemize}
	\item \textbf{Layout: } estará compuesta por un sidebar, un header y la plantilla yield.
	\item \textbf{Yield:} esta plantilla es dinámica y se podrá asignar una plantilla u otra dependiendo de la ruta en la que nos encontremos.
\end{itemize}
\paragraph{}
Partiendo del requisito de que los usuarios deben estar autenticados para acceder a la funcionalidad de la aplicación es necesario diseñar el flujo de registro de usuario y situarlo en un recurso o ruta. Debido a esta restricción el flujo se situará en el recurso raíz (/). Por lo que, dependiendo de si el usuario está autenticado o no al acceder a esta ruta deberá mostrarse una plantilla u otra. En este caso:
\begin{itemize}
\item Si el usuario está autenticado el layout estará compuesto por la plantilla \{\{$<$sidebar\}\},  \{\{$<$header\}\} y la plantilla \{\{$<$yield\}\} que corresponderá a la plantilla \{\{$<$startPage\}\}.
\item  Si el usuario no está autenticado el layout estará compuesto solamente por la plantilla \{\{$<$yield\}\} que corresponderá a la plantilla \{\{$<$mainPage\}\}.
\end{itemize}
El siguiente código muestra el fichero HTML de la plantilla \{\{layout\}\}:
\begin{lstlisting}[language=HTML]
<template name="layout">
    <div id="main-wrapper">
        {{#if currentUser}}
            {{> sidebar }}
            <div id="page-wrapper">
                {{> header}}
                {{> yield }}
            </div>
       	{{else}}
            {{> yield}}
            {{> loginModal }}
        {{/if}}
    </div>
</template>
\end{lstlisting}
El ayudante (helper) currentUser que proporciona Meteor proporciona una función cuyo valor de retorno es un objeto javascript si el usuario está autenticado o null si no lo está. Por lo que gracias a Spacebars y sus flujos de control (\{\{if\}\},\{\{else\}\}\,{\{/if\}\}) podemos realizar este diseño de forma sencilla.

\subsubsection{Sidebar y header}
\paragraph{}
Uno de los requisitos de la aplicación es que debe ser full-responsive. Esto es que se adapte a cualquier tamaño de pantalla. Por lo que es necesario un diseño adaptativo para cada pantalla de la aplicación en la que el layout no es excepción. Como se muestra en la figura \ref{fig:layoutFR}, la plantilla \{\{$<$sidebar\}\} se ocultará para pantallas estrechas y aparecerá la plantilla \{\{$<$header\}\}. Ésta constará de una serie de botones que al hacer click en cada uno de ellos hará que se se muestre el sidebar con el contenido correspondiente. El diseño del header puede verse siguiente figura: 
\begin{figure}[hb]
	\includegraphics[width=\textwidth]{header}
	\label{fig:header}
	\caption{Diseño header}
\end{figure}

\paragraph{}
El sidebar está compuesta por tres espacios diferenciados (figura \ref{fig:sidMenuV1}):
\begin{itemize}
	\item \textbf{Caja Principal:} en ella aparecerá el logo de la aplicación y el nombre que serán enlaces al recurso raíz (/).
	\item \textbf{Contenido:} el contenido del sidebar se organiza mediante un menú de tabs. 
	\item \textbf{Caja de usuario:} en ella aparecerá el avatar y el nombre de usuario que serán enlaces al recurso perfil y un botón para cerrar sesión.
\end{itemize}
\begin{figure}[htpb]
	\centering
	\includegraphics[height=0.72\textheight]{sidebarMenuVersion1}
	\label{fig:sidMenuV1}
	\caption{Diseño sidebar}
\end{figure}
\subsubsection{Configuración de Iron Router}
\paragraph{}
Iron Router permite establecer una configuración genérica para todas las plantillas especificando la plantilla de carga, el layout, plantilla notFound y subscripciones a las colecciones que necesitemos tener accesibles en todo momento. En este prototipo establecemos solamente la plantilla layout.
\paragraph{}
Puesto que acabamos de hablar del primer recurso de la aplicación debemos establecer una ruta para el mismo especificando qué plantilla ha de mostrarse de la siguiente manera:
\begin{lstlisting}[language=Javascript]
Router.configure({
	layoutTemplate: 'layout'
});

Router.route({'/',
	name: 'mainPage'
});
\end{lstlisting}

\subsection{Registro de usuarios}
\paragraph{}
Para el registro de usuarios creamos una plantilla llamada \{\{>loginModal\}\} que será un Modal de bootstrap y que mediante una variable de sesión de Meteor mostrará un formulario para que los usuarios puedan registrarse u otro para que puedan iniciar sesión. Esta variable de sesión podría ser global y podría ser utilizada para crear un formulario dinámico que dependiera del valor de dicha sesión. Por lo que creamos una plantilla genérica para formularios y después incluimos el que correspondiera según el valor de la variable como sigue:

\begin{lstlisting}[language=HTML]
<template name=loginModal>
	<!-- bootstrap modal-->
		{{>formAwesome}}
	<!-- end bootstrap modal-->
</template>
<template name='formAwesome'>
	{{Template.dynamic template=formTemplate}}
</template>

<template name='signInForm'>
	<button></button>
</template>
<template name='signUpForm'>
	<button></button>
</template>
\end{lstlisting}

\begin{lstlisting}[language=Javascript]
//Cuando el modal se renderiza en el DOM, se establece el valor por defecto
//que es que se muestre el formulario para iniciar sesión.
Template.loginModal.rendered = function(){
	Session.set('formTemplate','signInForm');
};
Template.formAwesome.helpers({
	//El helper template de la plantilla Template.dynamic hace que dicha 
	//plantilla se sustituya por la indicada en dicho helper
	formTemplate: function(){return Session.get('formTemplate')}
});
Template.signInForm.events({
	//cambiamos al formulario de registro.
	'click button': function(){Session.set('formTemplate','signUpForm')}
});

Template.signUpForm.events({
	//cambiamos al formulario de inicio de sesión.
	'click button': function(){Session.set('formTemplate','signInForm')}
});
\end{lstlisting}


\subsubsection{Formulario de inicio de sesión}
Atendiendo a los requisitos los usuarios para iniciar sesión deberán rellenar un formulario con dos campos (figura \ref{fig:signIn}):
\begin{itemize}
	\item \textbf{usuario}: nombre de usuario o email.
	\item \textbf{contraseña}: contraseña del usuario.
\end{itemize}
El inicio de sesión en Meteor se realiza mediante una llamada desde el cliente a la función loginWithPassword proporcionada por el paquete accounts-password pasando como argumento el nombre de usuario o email y la contraseña.
\subsubsection{Formulario de registro}
Atendiendo a los requisitos los usuarios para registrarse deberán suministrar un nombre de usuario, una contraseña y opcionalmente un email (figura \ref{fig:signUp}). El email servirá para la verificación del usuario y para acciones y gestiones que exploraremos más adelante. 
\begin{figure}[htbp]
    \centering
    \subfigure[Formulario de inicio de sesión]{
   	 \includegraphics[scale=0.5]{signInForm.png}
    	\label{fig:signIn}
    }
    \subfigure[Formulario de registro]{
    	\includegraphics[scale=0.45]{signUpForm.png}
	 \label{fig:signUp}
    }
    \caption{Diseño formularios de registro}
    \label{fig:signForms}
\end{figure}
El registro de usuarios en meteor se realiza mediante una llamada en el servidor a la función createUser que proporciona accounts-base. Puesto que el evento asociado al click del botón se encuentra en el cliente se necesita establecer un method en el servidor que sirva de enlace para el cliente. El cliente llamará al method y éste se ejecutará en el servidor llamando a la función createUser. De forma orientativa se muestra el siguiente código:

\begin{lstlisting}[language=Javascript]
if (Meteor.isClient){
	Template.signUpForm.events({
		'click button': function(e){
			var paramsUser; //extraemos los valores de los campos.
			Meteor.call('signUpMethod',paramsUser,function(err,res){
				if (err) throw new Meteor.error('Error al crear el usuario');
				if (res) console.log(usuario creado con id: res);
			});
		}
	});
};

if(Meteor.isServer){
	Meteor.methods({
		'signUpMethod': function(paramsUser){
			if (userIsValid(paramsUser)){
				return Accounts.createUser(paramsUser,callback)
			}else
				return false;
			}
	})
};
\end{lstlisting}

En el momento que el cliente realiza la llamada con los datos suministrados por el usuario, se deberá verificar que los datos son correctos y que cumplen una serie de reglas. (Validación de nuevo usuario). Una vez verificado se creará un objeto usuario en la colección disponible en Meteor.users cuya estructura es la mostrada en la figura \ref{userMongo}. En este momento ya tenemos definida la primera entidad de la aplicación (Usuarios).

El resultado de este prototipo puede verse a continuación:
\begin{figure}[htbp]
    \centering
    \subfigure[Formulario de inicio de sesión]{
   	 \includegraphics[width=0.7\textwidth]{sign-in-form.png}
    	\label{fig:signInReal}
    }
    \subfigure[Formulario de registro]{
    	\includegraphics[width=0.7\textwidth]{sign-up-form.png}
	 \label{fig:signUpReal}
    }
    \caption{Formularios de registro en Página de inicio}
    \label{fig:signFormsReal}
\end{figure}




\section{Prototipo 2: Grabador y reproductor basados en documentos}
\paragraph{}
Este prototipo engloba el diseño y desarrollo del grabador, del reproductor y del recurso en el que se muestran las grabaciones realizadas. 
\subsection{Grabador}
\subsubsection{Entidades y colecciones}
\paragraph{}
En este momento surgen dos nuevas entidades de la aplicación que son las grabaciones y los documentos. La relación que existe entre éstas y los usuarios viene determinada por el diagrama mostrado en la figura (TAL). Dicho diagrama impone que cualquier usuario puede crear una grabación y que ésta debe estar formada por uno o más documentos. Los documentos no existen independientemente de las grabaciones. Como todas las entidades, éstas se traducen en las colecciones Records y Documents cuyos objetos MongoDB se muestran en \ref{recordMongo} y \ref{documentMongo} respectivamente. Al contrario que la colección Users de Meteor, éstas no se crean por defecto. Por lo que, generamos dos nuevos ficheros javascript: app/lib/collections/records.js y app/lib/collections/documents.js. En cada fichero definimos la colección de la siguiente manera:
\begin{lstlisting}[language=Javascript]
	CollectionName = new Mongo.Collection('collectionName');
	//CollectionName será el nombre de la colección accesible en la aplicación.
	//collectionName será el nombre de la colección en MongoDB.
\end{lstlisting}
\subsubsection{Routing}

\paragraph{}
Es necesario crear una nueva ruta para el grabador. Esta ruta será /records/submit y estará accesible en todo momento cumpliendo los requisitos gracias a un nuevo diseño del sidebar que incluye un link a la lista de grabaciones y otro al recurso que acabamos de crear como se muestra en la figura \ref{fig:sidebarV2}.
\paragraph{}
Incluimos una nueva ruta en /app/lib/router.js:
\begin{lstlisting}[language=Javascript]
	Router.route('/records/submit',{
		name: 'recordSubmit'
	});
\end{lstlisting}
\{\{$>$recordSubmit\}\} será la plantilla para nuestro recurso.
\subsubsection{Proceso de grabación}
\begin{figure}[h]
    \centering
    \subfigure[Esquema]{
   	 \includegraphics[width=0.8\textwidth]{recordProcess.png}
    	\label{fig:recordProcessSched}
    }
    \subfigure[Lógica]{
    	\includegraphics[width=0.8\textwidth]{recordProcessObjects.png}
	 \label{fig:recordProcessLogic}
    }
    \caption{Proceso de grabación}
    \label{fig:recordProcess}
\end{figure}
\paragraph{}
Puesto que cada grabación tendrá dos componentes (audio y video) el proceso se realiza de forma diferente para cada una como se muestra en la figura \ref{fig:recordProcessSched} de forma esquemática.
\paragraph{}
Dicho esquema se traduce en la creación de dos objetos javascript: AudioRecorder y EditorManager. Apreciable en la figura \ref{fig:recordProcessLogic}
\begin{itemize}
	\item \textbf{AudioRecorder}: se trata de un constructor que nos permitirá crear un grabador de audio
	\item \textbf{EditorManager}: se trata de un constructor que nos permitirá crear un manejador de documentos, almacenar y actualizarlos de manera dinámica mientras se producen cambios en el editor. 
\end{itemize}
\paragraph{}
La API de RTCRecorder nos proporciona un grabador proporcionándole como parametros un el Stream del usuario y una serie de configuraciones. Para conseguir el Stream utilizamos el módulo navigator del navegador:

\begin{lstlisting}[language=Javascript]
	navigator.getUserMedia  = navigator.getUserMedia || 
						 navigator.webkitGetUserMedia || 
						 navigator.mozGetUserMedia || 
						 navigator.msGetUserMedia;
	var audioConstraints = {audio: true, video: false};
	navigator.getUserMedia(audioConstraints,function(stream){
		var settings = {}
		var recorder = window.RecordRTC(stream,settings);
		recorder.startRecording();
	},function(error){
		throw new Meteor.error(error.reason);
	});
\end{lstlisting}
El código anterior se encuentra dentro de un método (startRecording) del constructor AudioRecorder y la variable recorder se encuentra accesible por todos los métodos del mismo por lo que tenemos accesible el grabador proporcionado por RTCRecorder. 
\paragraph{}El proceso de grabación sobre el editor se basa en generar una lista de acciones indexadas por marcas de tiempo. Dichas marcas de tiempo corresponderán al instante en el que se produce un cambio en el editor y dicho cambio se traducirá en una acción (método proporcionado por la API de AceEditor) para que en ese instante durante el proceso de reproducción se ejecute dicha acción simulando el cambio que se haya producido durante la grabación.
\paragraph{}
Para lo anterior es necesario capturar los cambios del editor, a través de la API de AceEditor, y extraer el instante correspondiente. En el momento que comienza la grabación se ejecuta un callback pasado por parámetro que sirve para arrancar el reloj de la grabación. Dicho reloj será accesible dentro de la plantilla \{\{$>$recordSubmit\}\}. Por lo que la sincronización con los cambios en el editor será perfecta.
\paragraph{}
El siguiente código sirve de ejemplo para ilustrar la captura de eventos: 
\begin{lstlisting}[language=Javascript]
var editor = ace.editor('#id');
editor.getSession().on('change', function(e) {
     switch (e.action) {
     	case "remove":
         	var rmRange = {start: e.start, end: e.end};
          docsManagerRecorder.insertFunctions([{
                time: new Date() - date,
                arg: rmRange,
                toDo: 'editor.getSession().getDocument().remove(arg);'
           }]);
           break;
       }
});
\end{lstlisting}
\paragraph{}
Como puede verse en el código anterior docsManagerRecorder es nuestro objeto construido mediante EditorManager y mediante su método insertFunctions generamos nuevas acciones que se simularán durante la reproducción en el instante almacenado en su atributo time.

\paragraph{}
Puesto que una grabación debe estar formada por uno o más documentos, durante la grabación puede producirse la creación de nuevos documentos y del cambio de uno a otro sobre el editor. Estos cambios deben ser visibles durante la reproducción por lo tanto deben ser capturados. La captura se realiza mediante los eventos que se produzcan en la plantilla correspondiente al crearse un nuevo documento o visualizar otro distinto al actual. En el momento que alguno de estos eventos se produzca se generará una nueva acción que insertar en la lista de acciones mediante el método insertFunctions. 
\paragraph{}
Los eventos posibles que se traducen en acciones son los siguientes: 
\begin{itemize}
	\item Borrar: se borra contenido.
	\item Insertar: se inserta contenido.
	\item Selección: cambia la selección del cursor.
	\item Cursor: cambia la posición del cursor.
	\item Scroll: cambia la altura del scroll.
	\item Creación documento: el usuario crea un nuevo documento.
	\item Cambio de documento: el usuario selecciona otro documento distinto al actual para su visualización.
\end{itemize}

\subsubsection{Almacenamiento}
Como podemos observar en la figura \ref{fig:recordProcess}, una vez termina la grabación se deben proporcionar herramientas para su almacenamiento persistente. El almacenamiento de dicha grabación se realizará por separado según sus componentes. Un objeto record compuesto por información sobre la grabación y la lista de acciones (\ref{recordMongo}) se almacenará en la colección Records de MongoDB y el archivo de audio en SoundCloud. 
\paragraph{}
Para utilizar la API de SoundCloud es necesaria la instalación de un nuevo paquete: monbro:soundcloud-nodejs-api-wrapper  . Este paquete es un wrapper (envoltorio) del SDK (Software Development Kit) de SoundCloud que permite realizar llamadas REST a la API desde el lado del servidor gracias al objeto SoundCloud que nos proporciona de manera global. 
\paragraph{}
Para inicializar dicho objeto necesitaremos un usuario en SoundCloud y crear una aplicación en su espacio para desarrolladores. Dicha aplicación nos proporcionará una serie de credenciales que nos permitirán comunicarnos con la API: identificador de la aplicación, clave secreta de la aplicación. Al crearla necesitaremos proporcionarle una url de redirección para la autenticación mediante el protocolo OAuth. 
\paragraph{}
Usando solamente el SDK en el cliente, a la hora de conectar con la API, comenzaría un proceso de autenticación que mostraría un popup que exige interacción con el usuario. Dicho proceso no es transparente al usuario y eso es algo que hemos querido arreglar. La solución es incorporar como parámetro de incialización del SDK un token OAuth (el devuelto tras el proceso de autenticación). El problema está en que dicho token tiene una fecha de expiración y el SDK para Javascript no proporciona herramientas para refrescar el token ya que no tiene método para realizar esa petición REST en cuestión. Pero el paquete mencionado anteriormente sí tiene esa funcionalidad, y es que cada vez que llamamos a su método .getClient(), nos devuelve un cliente con un token completamente nuevo. 
\paragraph{}
Por este motivo creamos el fichero /app/server/soundcloud.js en el que inicializar el objeto SoundCloud y crear el method .getClientSC al que podemos llamar desde el cliente y que nos devuelve los parámetros necesarios para incializar el SDK del cliente de forma que se conecte a la API de SoundCloud de forma transparente al usuario.
\paragraph{}
El siguiente código ilustra este proceso: 
\begin{lstlisting}[language=Javascript]
if (Meteor.isServer()){
	Soudcloud.setConfig({
		client_id: CLIENT_ID,
		client_secret: CLIENT_SECRET,
		username: USERNAME,
		password: PASSWORD
	});
	
	Meteor.methods({
		getClientSC: function(){
			var client = Soundcloud.getClient();
			return {
				client_id: CLIENT_ID,
				access_token: client.settings.access_token
			}
		}
	});
}
if (Meteor.isClient()){
	$.getScript("https://cdn.WebRTC-Experiment.com/RecordRTC.js",function(){
		Meteor.call('getClientSC',function(err,res){
			if (err) throw new Meteor.error(err.reason);
			if (res){
				SC.initialize({
					client_id: res.client_id,
					oauth_token: res.access_token,
					scope: 'non-expiring'
				});
			}
		});
	});
}
\end{lstlisting}

\paragraph{}
Las variables CLIENT\_ID Y CLIENT\_SECRET contienen el id de la aplicación que hemos creado en Soundcloud y su clave secreta respectivamente.
\paragraph{}
Una vez que tenemos inicializado el SDK en el cliente podemos realizar la subida del audio de la siguiente manera: 
\begin{lstlisting}[language=Javascript]
var recordMongoObject = {};
SC.connect().then(function(){
	SC.upload({
		file: recorder.getAudio(), //Blob
		title: 'title'
	}).then(function(track){
		recordMongoObject.track = {
			id: track.id,
			link: track.uri
		}
		//llamada al servidor para almacenar el objeto.
	})
})
\end{lstlisting}
\paragraph{} 
En el código anterior se muestra cómo se crea una referencia al archivo subido mediante su identificador. Una vez tenemos el objeto completado realizamos la llamada al method insertRecord, creado en el archivo /app/lib/collections/records.js para almacenar la grabación en MongoDB.


\subsubsection{Interfaz del grabador}
La interfaz del grabador está formado por dos espacios: la pantalla en la que se mostrará una plantilla u otra dependiendo de las acciones a realizar y una caja con botones que determinarán dichas acciones. Además, como se graban documentos sobre editor, constará de una pestaña en la que aparecerá el título del documento que está siendo editado y un botón para acceder a la lista de documentos como se muestra en la figura \ref{fig:recorderBase}

\paragraph{}
El diseño del grabador se compone de las siguientes plantillas: 
\begin{itemize}
	\item \textbf{\{\{$<$initial\}\}}: es la que se muestra inicialmente y consta de un botón para mostrar la lista de documentos.
	\item \textbf{\{\{$<$documentList\}\}}: se muestra como un panel dentro de la pantalla de la interfaz y contiene un botón para mostrar el formulario de creación de documentos y la lista de documentos creados. Al hacer click en cada uno de ellos lo visualizaremos en la pantalla. Cada miniatura de los documentos posee un enlace de edición que muestra el formulario de creación con los datos del propio documento.
	\item \textbf{\{\{$<$documentForm\}\}}: es el formulario de edición y creación de los documentos. Se deberá introducir un título, un lenguaje de programación y un tema para el editor (estos dos últimos son opcionales).
	\item \textbf{\{\{$<$editor\}\}}: plantilla en la que se muestra el editor con el contenido de los documentos.
	\item \textbf{\{\{$<$actions\}\}}: esta plantilla está presente a lo largo de todo el proceso de grabación y determina las acciones a realizar según el estado del mismo (grabar, parar, guardar/cancelar).
	\item \textbf{\{\{$<$final\}\}}: al finalizar la grabación se muestra en la pantalla de la interfaz un mensaje.
	\item \textbf{\{\{$<$saveForm\}\}}: es el formulario para guardar nuestra grabación. Se deberá introducir un título y opcionalmente una descripción y una lista de etiquetas mediante un auto-completado de etiquetas que se ha elaborado.
	\item \textbf{\{\{$<$upload\}\}}:  al hacer click en guardar en la plantilla anterior se mostrará el progreso de subida del audio y cuando termine un mensaje y un enlace a la página de la grabación (reproductor) para reproducir la grabación.
\end{itemize}
\paragraph{}
Tras este análisis hemos encontrado una nueva entidad: etiquetas (Tags) por lo que creamos una nueva colección y un nuevo fichero en /app/lib/collections de forma análoga con las anteriores. Establecemos que una grabación puede tener o no etiquetas y que son globales es decir que la misma etiqueta la pueden tener una o varias grabaciones. Esta relación puede verse en el diagrama (tal). Además para tenerlas accesibles desde el formulario debemos crear una publicación a la que se subscribirá el cliente. Como es la primera, creamos el fichero /app/server/publications.js. Será el fichero en el que declararemos todas nuestras publicaciones. La subscripción a esta publicación se hará dinámicamente puesto que se trata de un auto-completado.
\paragraph{}
El flujo de plantillas se muestra en la figura \ref{fig:grabacionFlujo}
Las plantillas presentes en la figura anterior corresponden a las figuras: \ref{fig:recorderNoDocs}, \ref{fig:recorderDocsList}, \ref{fig:documentForm}, \ref{fig:recorderEditor}, \ref{fig:recorderFinal} y \ref{fig:uploadProcess} disponibles en el apéndice \ref{appendix:mockupsApendix}.
\paragraph{}
Una vez desarrollado el grabador este es el resultado:
\begin{figure}[htpb]
	\centering
	\includegraphics[width=0.75\textwidth]{recorder.png}
	\caption{Grabador}
	\label{fig:recorder}
\end{figure}
\begin{figure}[htpb]
	\centering
	\includegraphics[scale=0.4]{recorderFlow.png}
	\label{fig:grabacionFlujo}
	\caption{Flujo de plantillas del grabador}
\end{figure}
\paragraph{}
\paragraph{}\paragraph{}
\subsection{Reproductor}
\subsubsection{Ruta, publicaciones y subscripciones}
El reproductor es un módulo de la página de cada grabación que se establece en una nueva ruta de nuestro proyecto y la primera que establecemos como detalle (detail). La ruta será /record/:id donde id corresponderá al identificador del objeto grabación almacenado en MongoDB y estará configurada en /app/lib/router.js de la misma forma que las anteriores. 
\paragraph{}
La única diferencia es que ahora necesitaremos tener accesible el objeto grabación para realizar las acciones oportunas. Esto se consigue creando publicaciones y subscripciones. 

\begin{lstlisting}[language=Javascript]
	// app/server/publications.js
	Meteor.publishComposite('record',function(id){
		//Publicamos el record y los documentos asociados al mismo. 
		var sub = {
			find: function(){
				return Records.find(id)
			},
			children: [{
				find: function(record){
					return Documents.find({record_id: record._id});
				},
				{...}
			}];
		};
		return sub;
	});
\end{lstlisting}
Las subscripciones se realizarán mediante Iron Router a no ser que sean dinámicas. 
\begin{lstlisting}[language=Javascript]
// app/lib/router.js

Router.route('/record/:_id',{
	name: 'record',
	data: function(){
		return Records.findOne(this.params_id);
	},
	waitOn: function(){
		return Meteor.subscribe('record',this.params._id);
	}
});
\end{lstlisting}

De esta manera tendremos accesibles los datos del record y se establecerán como los datos de la plantilla \{\{$<$record\}\}.

\subsubsection{Proceso de reproducción}
Debido a que cada grabación está compuesta por audio y por vídeo sobre editor, se desarrollan dos procesos paralelos y sincronizados durante la reproducción de la misma (figura \ref{fig:playProcessSched}).
\begin{itemize}
	\item \textbf{Audio:} nos conectamos a SoundCloud y realizamos la petición del stream del audio correspondiente.
	\item \textbf{Vídeo (editor):} a medida que el audio se reproduce, se realiza la simulación de cada evento capturado durante la grabación de forma sincronizada.
\end{itemize}

\begin{figure}[h]
    \centering
    \subfigure[Esquema]{
   	 \includegraphics[width=0.8\textwidth]{playProcess.png}
    	\label{fig:playProcessSched}
    }
    \subfigure[Lógica]{
    	\includegraphics[width=0.8\textwidth]{playProcessObjects.png}
	 \label{fig:playProcessLogic}
    }
    \caption{Proceso de reproducción}
    \label{fig:playProcess}
\end{figure}

\paragraph{}
Al igual que durante la grabación, la labor de reproducción de cada una de las componentes recaerá en un objeto Javascript: RecordPlayer (audio) y EditorPlayerManager (editor) en los ficheros /app/client/lib/recordPlayer.js y /app/client/lib/editorPlayerManager.js respectivamente (figura \ref{fig:playProcessLogic}).
\begin{itemize}
	\item \textbf{RecordPlayer:} se encarga de ofrecer una interfaz lógica a partir del stream del audio proporcionado en su inicialización. Dicha interfaz recoge los métodos necesarios para la reproducción (.play(), .pause(), .seek(), .setVolume(), .ended()) y otros propios (.updateCover(), .getState(), .destroy()).
	\item \textbf{EditorPlayerManager:} se encarga de clasificar la lista de acciones capturadas y realizar su simulación. Además se encarga de mantener la integridad de los documentos de la grabación durante el proceso. Este objeto posee los métodos .getDocs(), .getDocActual(), .update() y .seek().
\end{itemize}
 

\subsubsection{Sincronización entre audio y editor}

Al inicializar el objeto RecordPlayer toma como argumento un objeto EditorPlayerManager ya inicializado con el identificador del editor. El método .play del objeto RecordPlayer inicia una llamada a su función .updatePlayer() mediante un Interval de 20. Esto quiere decir que cada 20 mílisegundos se ejecutará esta función que, a su vez, realiza una llamada a la función .update() del objeto EditorPlayerManager pasado como argumento. Por lo que cada 20 mílisegundos se mostrarán cambios en el contenido del editor.

\paragraph{}
Al llamar al método .pause() de RecordPlayer se destruirá la programación del objeto Interval, con lo que parará de inmediato los cambios sobre el editor. 
\paragraph{}
Al saltar entre instantes de la reproducción se llamará al método .seek(). Este método realiza una llamada directa al método .updatePlayer() y por tanto al método .update() de EditorPlayerManager, pasando como parámetro el instante exacto.

\subsubsection{Simulación de eventos sobre editor}
La simulación se realiza en el método .update() del objeto EditorPlayerManager. El objeto posee la lista de acciones completa, la cual no se alterará en ningún momento. Al inicializarse se realiza una copia en una variable global del objeto. En el momento que se produce la llamada al método .update() dicha lista se filtra (se escogen las acciones cuyo instante de creación sea menor o igual que el instante actual de la reproducción). Después se clasifican estas acciones y se ejecutan en orden. Después se actualiza el valor de la variable donde estaba la copia de las acciones eliminando de esa lista los ya simuladas. 

\begin{lstlisting}[language=Javascript]
EditorPlayerManager = function(){
	var RC, listPending, editor;
	
	this.initialize = function(params){
		RC = params.RC;
		listPending = RC;
		editor = ace.edit(params.editor);
	};
	
	this.update = function(pos){
		//filtramos las acciones a ejecutar
		var listToDo = _(listPending).filter(function(action){
			return action.time <= pos;
		});
		
		//ejecutamos las acciones que corresponden.
		_(listToDo).each(function(action){
			switch(action.type){
				//ejecución de las funciones guardadas sobre el editor.
			}
		});
		
		//actualizamos la lista de acciones pedientes.
		listPending = _(listPending).difference(listToDo);
	}
}
\end{lstlisting}

El anterior código ilustra el proceso descrito.

\subsubsection{Interfaz del recurso grabación}
\paragraph{}
Se trata de un recurso de detalle (detail resource) y en este proyecto se ha hecho un diseño base (figura \ref{fig:detailBase}) para este tipo de recurso basado en tres espacios: 
\begin{itemize}
	\item {Banner: } este será el espacio dedicado para la presentación de la información relativa al objeto correspondiente al recurso.
	\item {NavbarTab: } barra de navegación basada en tabs para elegir qué contenido, asociado al objeto, visualizar.
	\item {tabContent: } espacio en el que se muestran el contenido escogido.
\end{itemize}
\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{pageDetailBase.png}
	\caption{Diseño página de detalle}
	\label{fig:detailBase}
\end{figure}
El banner, en este caso, mostrará la información de la grabación (autor, descripción, título, fecha de creación, contadores y lista de etiquetas), un botón para votar, la plantilla \{\{$<$player\}\} para el reproductor y la plantilla \{\{$<$actions\}\} como se muestra en el diseño (figura \ref{fig:recordBanner}).

\begin{figure}[h]
	\centering
	\includegraphics[width=0.6\textwidth, height=10cm]{RecordBanner.png}
	\caption{Diseño banner para una grabación}
	\label{fig:recordBanner}
\end{figure}

\subsubsection{Interfaz del reproductor}
\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\textwidth]{playerV1}
	\caption{Diseño interfaz del reproductor}
	\label{fig:playerV1}
\end{figure}
La interfaz del reproductor (figura \ref{fig:playerV1})estará compuesta por el editor, una capa superpuesta vinculada a los eventos play y pause y la plantilla \{\{$<$playerActions\}\} en la que se muestra el progreso, el timer, un controlador de volumen y los botones play y pause cuando correspondan. Además en la parte superior aparecerá una pestaña en la que se mostrará información sobre el documento actual (título y lenguaje).
\subsubsection{Streamming}
La plantilla \{\{$<$player\}\} se instancia mediante un helper de la plantilla \{\{$<$record\}\} cuyo valor es un objeto Javascript con los datos necesarios para construir e inicializar los objetos RecordPlayer y EditorPlayerManager y el identificador del audio almacenado en SoundCloud. 
\paragraph{}
Como se muestra a continuación, en el método .rendered() es necesaria la conexión con SoundCloud para realizar la petición de un stream de audio que poder suministrar al objeto RecordPlayer creado: 
\begin{lstlisting}[language=Javascript]
// app/client/modules/record_modules/record/player.js

Template.player.rendered = function(){
	var self = this.
	Meteor.call('getClientSC',function(err,res){
		if (res){
			SC.initialize ({
				client_id: res.client_id,
				auth_token: res.auth_token,
				scope: 'non-expiring'
			});
			SC.connect().then(function(){
				SC.stream('tracks/' + self.track_id)
					.then(function(s){
						this.recordPlayer.initialize(s,
							this.editorPlayerManager, ...);
					});
			});
		}
	});
}
\end{lstlisting}
\paragraph{}
El resultado final del reproductor puede verse en la siguiente figura: 
\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{record-player.png}
	\caption{Reproductor}
	\label{fig:recordPlayerPage}
\end{figure}
\subsection{Lista de grabaciones}
\subsubsection{Ruta, publicaciones y subscripciones}
La lista de grabaciones se mostrará en una nueva página o recurso de la aplicación. Dicho recurso corresponde a la ruta /records y a la plantilla \{\{$<$records\}\}. Como en cada nueva ruta es necesario integrarla en /app/lib/router.js y, en este caso, crear las publicaciones y subscripciones necesarias.
\begin{lstlisting}[language=Javascript]
// app/server/publications.js

Meteor.publishComposite('records',function(){
	var sub = {
		find: function(){
			return Records.find({},{fields: {RC:0, track: 0, tags: 0}});
		},
		children: [{
			find: function(record){
				return Meteor.users.find(record.author,
						{fields: {username: 1, avatar: 1}});
			}
		}]
	}
});

// app/lib/router.js

Router.route('/records',{
	name: 'records',
	waitOn: function(){
		return Meteor.subscribe('records');
	}
});
\end{lstlisting}
\paragraph{}
De esta manera nos subscribimos a las grabaciones y a los usuarios que las han creado. Filtramos los campos innecesarios para agilizar el proceso de renderizado.
\subsubsection{Interfaz}
La interfaz es muy sencilla (figura \ref{fig:recordsPage}). Está formada por dos espacios:
\begin{itemize}
	\item \textbf{logo:}  en este espacio se muestra el logo, el título de la lista y un enlace al recurso creación correspondiente.
	\item \textbf{\{\{$<$recordsTabContent\}\}:} este espacio será genérico para la aplicación y es que en cualquier parte de la aplicación que se quieran listar grabaciones se utilizará esta plantilla. Está formada por:
	\begin{itemize}
		\item \textbf{\{\{$<$contentNavbar\}\}:} en ella aparecen una serie de filtros (recientes, populares), opciones de visualización y un tab para iniciar el buscador.
		\item \textbf{\{\{$<$content\}\}:} en esta plantilla se listarán las grabaciones mediante miniaturas (figura \ref{fig:miniaturesRecord}) según el modo de visualización y aparecerá un botón para cargar más ítems.
	\end{itemize}
\end{itemize}

Tras el desarrollo de la interfaz el resultado se muestra en la siguiente figura:
\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{records.png}
	\caption{Lista de grabaciones}
	\label{fig:records}
\end{figure}
\paragraph{}
\paragraph{}
\section{Prototipo 3: Respuestas a grabaciones}
En este prototipo actualizamos la lógica del grabador y añadimos nuevas acciones para la página de detalle de grabación.
\subsection{Actualización del grabador}
Las respuestas a grabaciones se realizan mediante nuevas grabaciones sobre editor según los requisitos de la aplicación. La única diferencia es que esta vez el grabador se debe iniciar con los documentos de la grabación a la que queremos responder. Además el contenido de dichos documentos debe corresponder al instante en el que hemos pausado la reproducción. 
\paragraph{}
Para todo lo anterior necesitamos inicializar, con el estado de dichos documentos, al objeto que se encarga de manejarlos durante la grabación (EditorManager).  Pero antes necesitamos extraer dicho estado durante la reproducción. Para esto el objeto recordPlayer cuenta con el método .getState() que devuelve un objeto con el último instante de reproducción y la lista de documentos con su estado actual. Dicho objeto se almacenará en una variable de sesión accesible desde el fichero /app/lib/router.js. 
\paragraph{}
Para inicializar el objeto EditorManager como se ha descrito, necesitamos tener esos documentos accesibles desde los datos de la plantilla \{\{$<$recordSubmit\}\}. De esto se encarga Iron Router. La forma de especificar nuestra intención de realizar una grabación respuesta a Iron Router es mediante una query string (cadena de consulta). En ella se especificará el identificador de la grabación a la que queremos responder y la clave será parent\_id.
\begin{lstlisting}[language=Javascript]
Router.route('/records/submit',{
	...
	data: function(){
		var data = {}
		if (this.params.query){ //es una respuesta
			var playerState = (Session.get(playerState));
			(playerState)? data.playInstantObject = playerState : null;
		}
		return data;
	},
	waitOn: function(){
		if (this.params.query){
			return Meteor.subscribe('recordDocuments'
						this.params.query.parent_id);
		}
	}
});
\end{lstlisting}
\paragraph{}En el código anterior podemos ver cómo se configuran los datos de la plantilla del grabador y cómo nos subscribimos a los documentos de la grabación padre.
\paragraph{}
Hay que tener en cuenta que en el momento que abandonemos la página del grabador, la variable de sesión deberá ser destruida. Esto supone un problema. Si abandonamos la página del grabador y después volvemos a ella, Iron Router interpreta que queremos hacer una grabación respuesta. Esto se debe a que la query string no desaparece. Por este motivo se ha establecido que si volvemos al grabador se comenzará con los documentos en el estado final de la grabación padre. Dichos documentos los tenemos accesibles gracias a la publicación correspondiente y a la subscripción mediante el método waitOn de la ruta descrita en el código mostrado.
\paragraph{}
Como se muestra en el objeto (\ref{recordMongo}), cuando almacenemos la respuesta en MongoDB debemos incluir dos campos: isReply y parent\_id. 
\subsection{Nuevas acciones}
En la plantilla \{\{$<$actions\}\} de la interfaz de detalle de grabación (figura \ref{fig:recordBanner}) creamos dos botones: uno como enlace al grabador para crear una respuesta (sólo estará disponible si la reproducción se encuentra pausada o finalizada) y otro como enlace a la grabación padre (sólo disponible si se trata de una respuesta).
\begin{lstlisting}[language=HTML]
<div id='actions'>
	{{#if isPosibleToReply}}
		<button id='reply-button'>reply</button>
	{{/if}}
	{{#if isReply}}
		<button id='go-to-parent-button'>parent</button>
	{{/if}}
</div>
\end{lstlisting}

\begin{lstlisting}[language=Javascript]
Template.record.events({
	'click button#reply-button': function(){
		Session.set('playerState',this.recordPlayer.getState());
		Router.go('recordSubmit',{},{query: 'parent_id=' + this._id});
	},
	'click button#go-to-parent-button': function(){
		Router.go('record',{_id: this.parent_id});
	}
});
\end{lstlisting}

En el código anterior podemos apreciar la lógica del proceso descrito anteriormente.
\subsection{Timeline, relacionados y comentarios}
En este prototipo se han generado las secciones de contenido de la página detalle de una grabación mostradas en la figura \ref{fig:detailBase}: \{\{navbarTab\}\}(figura \ref{fig:navbarTabDesign}) y \{\{tabContent\}\}. La plantilla \{\{navbarTab\}\} se ha diseñado como componente de manera que pueda ser configurada con las tabs que correspondan para cada página de detalle.

\paragraph{}
Para listar las respuestas de una grabación se ha creado un timeline (figura \ref{fig:repliesTab}). Dicho timeline se muestra al seleccionar la tab Replies del \{\{$<$navbar\}\} de la página de la grabación.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\textwidth]{repliesTab.png}
	\caption{Diseño de timeline}
	\label{fig:repliesTab}
\end{figure}

\paragraph{}Además se ha añadido una nueva sección de contenidos para mostrar las grabaciones relacionadas con la grabación actual (figura \ref{fig:commentsTab}). Para ello se ha modificado la publicación 'record'. Ahora publicará, además de la grabación actual, otras que posean etiquetas similares.

\begin{figure}[htpb]
	\centering
	\includegraphics[width=0.7\textwidth]{commentsTab.png}
	\caption{Diseño del módulo de comentarios}
	\label{fig:commentsTab}
\end{figure}

\begin{figure}[htpb]
	\centering
	\includegraphics[width=0.7\textwidth]{relatedTab.png}
	\caption{Lista de relacionados}
	\label{fig:relatedTab}
\end{figure}

\paragraph{}También se ha creado una nueva sección que contiene un espacio para realizar comentarios (figura tal) y con ello surge una nueva entidad. Dicha entidad se traduce en una nueva colección Comentarios cuyo objeto se muestra en \ref{commentMongo} y su relación con las demás entidades en la figura \ref{fig:relatedTab}. Esta sección esta compuesta por una caja para introducir el texto a publicar y la lista de comentarios. Cada comentario está compuesto por el avatar del autor, el texto, una lista de las respuestas a ese comentario y la misma caja de texto mencionada anteriormente responder.

\paragraph{}
Se ha diseñado el espacio para comentarios de manera que sea genérico, es decir, que se pueda utilizar para todo tipo de contenidos. Tras la implementación el resultado puede verse en las figuras (tal),(tal) y (tal).




\section{Prototipo 4: Organización en Canales}
En este prototipo aparece por primera vez el concepto de organización en canales. La implementación de este concepto deberá cumplir todos los requisitos establecidos en \ref{sec:requisitos} correspondientes. 

\subsection{Concepto, entidades y modificaciones}
Un canal es un espacio público en el que crear grabaciones. Al ser público cualquier usuario puede acceder a sus contenidos de forma inmediata. También ofrece la posibilidad de crear comentarios, subscribirse y de votar. 
\paragraph{}
Con esta descripción surgen dos nuevas entidades: canales y subscripciones. Dichas entidades se traducen, al igual que las anteriores, en las colecciones Channels y UsersEnrolled respectivamente, cuyos objetos MongoDB son \ref{channelMongo} y \ref{userEnrolledMongo}. Para cada colección se crea un fichero en /app/lib/collections de la misma forma que para las anteriores. La relación entre entidades se muestra en la figura (tal)
\paragraph{}
Puesto que el contenido del canal se constituye en base a las grabaciones, esa relación deberá reflejarse en los objetos de las mismas. Para ello contarán con el atributo channel\_id las grabaciones pertenecientes a los canales como puede verse en \ref{recordMongo}. Como se describió en el proceso de grabación, una vez terminada la grabación y completado el proceso de uploading a SoundCloud se procedía con la creación de un objeto grabación. En esta fase habrá que determinar si la grabación que se ha realizado pertenece a un canal o es independiente. Para ello utilizamos query strings o cadenas de consulta que incluimos en la url del recurso grabador. En este caso la query será channel\_id$=$idValue. A modo de ejemplo y siendo el identificador del canal en el que queremos crear una nueva grabación la cadena QwIJOpIsAXzc la url del recurso grabador sería /records/submit?channel\_id$=$QwIJOpIsAXzc. Iron Router provee herramientas que permiten realizar esta función de forma sencilla.
\begin{lstlisting}[language=Javascript]
//app/client/modules/channels_module/channel.js
Template.channel.events({
	'click button#create-recording': function(){
		Router.go('recordSubmit',{},{query: 'channel_id=' + this._id});
	}
});

//app/lib/router.js

Router.route('/records/submit',{
	...
	data: function(){
		var data = {};
		(this.params.query.channel_id)? data.channel_id = this.params.query.channel_id : null;
		return data;
	}
})

//app/client/modules/records_module/recordSubmit/recordSubmit.js

SC.upload(audio).then(function(){
	var object = {};
	if (this.data.channel_id){
		object.channel_id = this.data.channel_id;
	}
	Meteor.call('insertRecording',object,function(err,result){});
});
\end{lstlisting}
En el código anterior se muestra un ejemplo de implementación del proceso descrito.
\subsection{Rutas y subscripciones}
Los canales, al ser un contenido más en la aplicación deberán de tener un recurso de creación y su propio recurso. Además contarán con un recurso de edición para cambiar la configuración del mismo.
Estos recursos serán: /channels, /channels/submit, /channel/:\_id y /channel/:\_id/edit. 
\paragraph{}
Tanto en el recurso de edición como en el propio del canal necesitaremos subscribirnos a los contenidos del canal correspondientes. Por esto creamos una nueva publicación en /app/server/publications.js compuesta por todos los contenidos. A saber: el propio canal, los usuarios subscritos y las grabaciones y comentarios del mismo. Para el recurso de edición sólo es necesario algunos campos del objeto MongoDB del canal. Por lo que creamos una nueva publicación para esta información. En el recurso /channels necesitaremos subscribirnos a los datos informativos de todos los canales del sitio. Para ello crearemos otra publicación compuesta.
\subsection{Diseño de interfaces e implementación}
\subsubsection{Creación de un canal}
\begin{figure}[htpb]
	\centering
	\includegraphics[width=0.7\textwidth]{createChannel.png}
	\caption{Formulario de creación para un canal.}
	\label{fig:createChannel}
\end{figure}
La información básica de un canal estará formada por un título, una descripción y una lista de etiquetas. La interfaz de creación de un canal deberá permitir la introducción de dicha información (figura \ref{fig:createChannel}). Utilizamos el sistema de formularios dinámicos basados en variables de sesión que describimos en el prototipo 1 y el complemento de etiquetas que diseñamos en el prototipo 2 para la plantilla \{\{$<$saveForm\}\}. Además creamos un nuevo method en el servidor al que llamaremos desde el cliente para almacenar el objeto canal una vez introducida la información necesaria.
\begin{lstlisting}[language=Javascript]
//app/lib/collections/channels.js
Meteor.methods({
	insertChannel: function(channelObj){
		return Channels.insert(channelObj);
	}
});

//app/client/modules/channels_module/channelSubmit.js
Template.channelSubmit.events({
	'submit form': function(e,template){
		var obj = {};
		obj.title = template.find('[name=title]').value();
		obj.description = template.find('[name=description]').value();
		obj.tags = Session.get('tagsChosen');
		Meteor.call('insertChannel',obj,function(err,res){
			if (err) throw new Meteor.Error('ERROR insertChannel');
			if (res) console.log('channel inserted with id: ' + res);
 		});
	}
});
\end{lstlisting}
\subsubsection{Página de canales}
Este es la página correspondiente al recurso /channels y en ella los usuarios podrán navegar por la lista de canales del sitio. Su diseño (figura \ref{fig:channelsPage}) es equivalente al diseño de la lista de grabaciones y se compone de un logo, un enlace al recurso de creación y un sistema de tabs para realizar filtros y mostrar resultados. Este recurso estará accesible desde el sidebar como se muestra en la versión 3 del mismo (figura \ref{fig:sidebarVersions}).
\subsubsection{Página del canal}
Al tratarse de un recurso de detalle, el diseño base de la interfaz será el mostrado en la figura \ref{fig:detailBase}. En el \{\{banner\}\} aparecerá el título del canal, su descripción, la lista de etiquetas, un logo, una imagen de fondo, un enlace al recurso de edición y una caja en la que se mostrará la información de su creador. Además incorporará la plantilla \{\{actions\}\} que permitirá subscribirse o cancelar la subscripción y votar dicho canal (figura \ref{fig:channelBanner}).
\begin{figure}[htpb]
	\centering
	\includegraphics[width=0.7\textwidth]{ChannelBanner.png}
	\caption{Diseño del banner de un canal}
	\label{fig:channelBanner}
\end{figure}
\paragraph{}
El \{\{navbarTab\}\} contendrá las tabs (figura \ref{fig:navbarTabDesign}): 
\begin{itemize}
	\item \textbf{Recordings:} si se selecciona se mostrarán en \{\{contentTab\}\} las grabaciones pertenecientes al canal. Dichas grabaciones podrán ser filtradas por los filtros recientes y populares. Además aparecerá un enlace al recurso de creación para una grabación.
	\item \textbf{Comments:} mostrará la lista de comentarios realizados.
	\item \textbf{Users:} mostrará la lista de usuarios subscritos.
\end{itemize} 
\subsubsection{Edición de un canal}
En este recurso se podrá editar la descripción, el logo, la imagen de fondo y la lista de etiquetas del canal. Utilizamos el sistema de formularios dinámicos mediante la inclusión de la plantilla \{\{$<$awesomeForm\}\}. Al tratarse del primer recurso de edición que nos encontramos en el proyecto, diseñamos una plantilla base (figura \ref{fig:editFormBase}) que podremos reutilizar en cada recurso de este tipo. Dicha plantilla se basa en la incorporación dinámica de complementos o componentes que desarrollaremos para cada tipo de información y que nos permitirá editarlos. 
\paragraph{}
La entrada y la salida de datos de dicho formulario será una variable de sesión que configuraremos en la plantilla del recurso de edición correspondiente. El valor de dicha variable será un objeto con la información actual del objeto a editar y con una serie de configuraciones que hará que se muestren unos complementos u otros. En este momento se desarrollan los siguientes complementos: 
\begin {itemize}
	\item \textbf{AvatarEdit: } permitirá la edición de cualquier tipo de imagen. Las opciones serán establecer una por defecto, escoger una desde el disco o introducir una url.
	\item \textbf{DescriptionEdit: } con este complemento editaremos cualquier información basada en texto mediante un textarea.
	\item \textbf{TagsEdit: } con este complemento editaremos la lista de etiquetas. Además incorpora el sistema búsqueda de etiquetas ya desarrollado.
\end {itemize}
\paragraph{}
El diseño de estos complementos y el del formulario pueden verse en las figuras \ref{fig:formEditComplements} y \ref{fig:channelEdit} correspondientemente.



\section{Prototipo 5: Organización en Lecciones}
En este prototipo aparece por primera vez el concepto de organización en lecciones. La implementación de este concepto deberá cumplir los requisitos establecidos en \ref{sec:requisitos}.

\subsection{Concepto, entidades y modificaciones}
Una lección es un espacio privado en el que crear grabaciones. Esta privación se traduce en que la creación de contenido inmediato para cada lección recae en la figura del usuario creador y que el contenido es privado para los usuarios que no estén subscritos a la misma. Además la estructuración del contenido de cada lección estará basada en secciones.
\paragraph{}
Con la anterior descripción surgen dos nuevas entidades: lecciones y secciones. Estas entidades se traducen en las colecciones Lessons y Sections cuyos objetos son \ref{lessonMongo} y \ref{sectionMongo} respectivamente. Se crean los ficheros /app/lib/collections/lessons.js y /app/lib/collections/sections.js en los que se declararán las colecciones y se implementarán los methods para gestionar sus modificaciones. Su relación con las demás entidades se muestra en la figura (tal).
\paragraph{}
Cada sección estará compuesta de grabaciones. Por lo que dichas grabaciones harán referencia a la sección y a la lección que pertenecen, además de indicar el orden dentro de la sección. Cada sección poseerá también un orden dentro de cada lección. Estos parámetros serán necesarios a la hora de editar las listas en el recurso de edición de la lección. Al igual que para las grabaciones pertenecientes a un canal, informamos al grabador de que se trata de una grabación perteneciente a una lección mediante la url. Esta vez formada por varias query string: lesson\_id, section\_id y order (\ref{recordMongo}). 
\begin{lstlisting}[language=Javascript]
//app/lib/router.js
Router.route('record/submit',{
	...
	data: function(){
		var data = {};
		....
		(this.params.query.lesson_id)? data.lesson_id = this.params.query.lesson_id : null;
		(this.params.query.section_id)? data.section_id = this.params.query.section_id : null;
		(this.params.query.order)? data.order = this.params.query.order : null;
	}
});

//app/client/modules/record_modules/recordSubmit/recordSubmit.js
SC.upload(file).then(function(){
	var obj = {}
	if (this.data.lesson_id){
		obj.lesson_id = this.data.lesson_id;
		obj.section_id = this.data.section_id;
		obj.order = this.data.order;
	}
	Meteor.call('insertRecord',obj,function(err,res){});
});
\end{lstlisting}
\subsection{Rutas y subscripciones}
Los recursos que se establecen para este contenido son: /lessons/submit, /lessons, /lesson/:\_id y /lesson/:\_id/edit (creación, listado, propio y creación).
\paragraph{}
Creamos una publicación compuesta para el recurso detalle, una publicación simple para el recurso de edición y otra compuesta para el recurso de listado a las que nos subscribiremos mediante el método .waitOn de cada ruta establecida en /app/lib/router.js para cada recurso.
\subsection{Lista de reproducción y opciones}
\begin{figure}[htpb]
	\centering
	\includegraphics[width=0.7\textwidth]{playlist.png}
	\caption{Diseño lista de reproducción}
	\label{fig:playlist}
\end{figure}
Debido a que el contenido de las lecciones se estructura en secciones que no son más que una lista de grabaciones, introducimos el concepto de lista de reproducción para el proyecto. Esto es, cuando reproduzcamos una grabación perteneciente a una lección, el reproductor mostrará la lista de grabaciones de la sección a la que pertenece. Además permitirá la navegación por ella y establecer las opciones de reproducción y repetición automática. 
Estas configuraciones se realizarán en el objeto del usuario mediante los atributos: auto\_play y auto\_repeat. Las funciones son las siguientes: 
\begin {itemize}
	\item \textbf{Reproducción automática: } al terminar la reproducción de cada elemento de la lista se comienza con la del siguiente.
	\item \textbf{Repetición automática: } convierte la lista de grabaciones en una lista circular. El elemento siguiente del último es el elemento primero y el elemento anterior al primero es el último.
\end{itemize}
\paragraph{}
Si se da el caso de que ambas funciones están activadas, la reproducción de la lista de grabaciones de una sección es infinita.
El diseño de la misma puede verse en la figura \ref {fig:playlist}
\subsection{Diseño de interfaces e implementación}
\subsubsection{Creación de una lección}
La información básica de una lección está formada por un titulo, una descripción y una lista de tags. Para su implementación utilizamos el sistema de formularios dinámicos mediante variables de sesión e integramos en la plantilla del formulario (figura \ref{fig:createChannel}) los complementos que permitan la introducción de dicha información (los mismos que para el recurso de creación de un canal).
\subsubsection{Página de lecciones}
En esta página los usuarios podrán explorar las lecciones del sitio. Su diseño (figura \ref{fig:lessonsPage}) esta formado por un logo, un enlace al recurso de creación para las lecciones y un sistema de tabs. Este sistema de tabs es el mismo que hemos desarrollado para la página de las grabaciones. Este recurso estará accesible desde el sidebar como se muestra en la versión 3 del mismo (figura \ref{fig:sidebarVersions}).
\subsubsection{Página de una lección}
\begin {figure}[htpb]
	\centering
	\includegraphics[width=0.7\textwidth]{LessonBanner.png}
	\caption{Diseño del banner de una lección}
	\label{fig:lessonBanner}
\end{figure}
Al tratarse de un recurso de detalle, tendrá el mismo diseño base que con los que comparte dicha clasificación (figura \ref{fig:detailBase}). En el \{\{banner\}\} aparecerá el título de la lección, el logo, la descripción, un apartado con la información sobre el autor y los contadores de la lección, la lista de etiquetas y la plantilla \{\{actions\}\} que permitirá a los usuarios realizar determinadas acciones según su rol: 
\begin{itemize}
	\item \textbf{Autor: } podrá votar y acceder al recurso de edición.
	\item \textbf{Visitante: } si está subscrito podrá votar y cancelar su subscripción y, si por el contrario, no lo está, podrá subscribirse.
\end{itemize}
\paragraph{}
El \{\{navbarTab\}\} contendrá las tabs (figura \ref{fig:navbarTabDesign}):
\begin{itemize}
	\item \textbf{Sections: } si se encuentra seleccionada, en \{\{contentTab\}\} se mostrará el listado de las secciones y un botón para acceder a un modal con el formulario para crear las mismas.
	\item \textbf{Comments: } lista de comentarios de la lección.
	\item \textbf{Users: } lista de usuarios subscritos.
\end{itemize}
\paragraph{}
Cada ítem sección estará formado por una cabecera y por un sistema de tabs implementado mediante un collapsible de Bootstrap. Ciertas acciones sobre estos elementos serán accesibles o no dependiendo del rol del usuario basándonos en los requisitos establecidos. Esto se refleja en la figura \ref{fig:sectionsTab}. Cada ítem en su cabecera mostrará el número de grabaciones, un botón para eliminar la sección, un botón para reproducir los contenidos y un enlace al recurso de creación de las grabaciones (grabador). El sistema de tabs estará formado por dos pestañas. En una aparecerá la lista de grabaciones (enlaces al reproductor) y en la otra la lista de grabaciones con botones para editar el orden dentro de la sección. Todas las acciones que pretendan crear, modificar o borrar están suprimidas para los usuarios con el rol de visitante.
\subsubsection{Edición de una lección}
Al tratarse de un recurso de edición, utilizamos el diseño implementado anteriormente. La plantilla \{\{$<$awesomeForm\}\} para cargar el formulario base mostrado en la figura \ref{fig:editFormBase} y a dicho formulario integramos los componentes \ref{fig:formEditComplements} avatarEdit, descriptionEdit, tagsEdit y además creamos uno nuevo para poder editar el orden de las secciones. El diseño se muestra en la figura \ref{fig:lessonEdit} 

\section{Prototipo 6: Página de perfil y Contactos}
En este prototipo se ha diseñado e implementado la página de perfil del usuario y un espacio para realizar solicitudes de contacto y mostrar esas relaciones entre los distintos usuarios.
\subsection{Perfil}
Se trata de un nuevo módulo y recurso cuya ruta será /profile/\_id, donde \_id corresponderá al id del usuario en cuestión. Se crean nuevas publicaciones y subscripciones y se establece la ruta en /app/lib/router.js.

\subsubsection{Interfaz}
Al tratarse de un recurso de detalle compartirá la misma base que los demás (figura \ref{fig:detailBase}). El \{\{banner\}\} estará formado una cabecera en la que se muestran el avatar del usuario, una imagen de fondo, un botón para acceder al recurso de edición del perfil y una caja con acciones y un cuerpo en el que aparece el nombre de usuario, la descripción y lista de servicios (figura \ref{fig:profileBanner}). 

\begin{figure}[htpb]
	\centering
	\includegraphics[width=0.9\textwidth]{profileBanner.png}
	\caption{Diseño banner del perfil}
	\label{fig:profileBanner}
\end{figure}

\subsubsection{Contenidos}
Utilizamos el complemento navbarTab y lo configuramos para que tenga las tabs canales, lecciones, grabaciones, conversaciones y contactos que corresponden a las categorías de contenido de la aplicación (figura \ref{fig:navbarTabDesign}).
Podemos reutilizar las plantillas  \{\{contentTab\}\} para mostrar las listas de contenido según la categoría que hemos generado para los recursos /records, /channels y /lessons. Sólo aparecerán las del usuario en cuestión, ya que nos hemos subscrito a sus contenidos. Aunque en este caso no existe la opción de iniciar el buscador, sino que se añaden nuevos filtros (figuras \ref{fig:recordsPage}, \ref{fig:lessonsPage} y \ref{fig:channelsPage} ): 
\begin{itemize}
	\item \textbf{Subscrito: }muestra los canales o lecciones a los que se ha subscrito el usuario según corresponda.
	\item \textbf{Historial: }muestra un total de 10 entradas. Dichas entradas serán las 10 últimas reproducciones que el usuario haya visualizado y formarán parte del  \{\{contentTab\}\} para las grabaciones.
\end{itemize}
\paragraph{}
Además se han incluido nuevos enlaces en el sidebar para acceder a los contenidos del perfil de forma directa mediante una query string que establece el contenido a visualizarse al cargar el perfil como puede verse en el diseño MenuTabV4 del sidebar (figura \ref{fig:sidebarVersions}). También se han incluido los enlaces necesarios en todas las cajas de usuario de los recursos detalle y en sus miniaturas.
\subsubsection{Roles}
Al visualizar cualquier página de perfil un usuario puede adoptar uno de estos dos roles: 
\begin{itemize}
	\item \textbf{Propietario:} lo adoptará el usuario que sea propietario de dicho perfil. Podrá acceder a la lista de servicios y al recurso de edición del perfil, además en cada \{\{contentTab\}\} se le mostrará un enlace al recurso de creación correspondiente. 
	\item \textbf{Visitante:}  lo adoptará el usuario que no sea propietario de dicho perfil. Podrá acceder a las acciones presentes en la cabecera del banner. Sólo existirá una, de momento: realizar peticiones de contacto.
\end{itemize}
\subsubsection{Edición del perfil}
Al igual que para editar las lecciones o los canales se establece un nuevo recurso para editar el perfil cuya ruta es /profile/:\_id/edit. Como en las otras es necesario declararla en /app/lib/router.js crear una nueva plantilla \{\{$<$profileEdit\}\} en /app/client/modules/profile\_modules/profileEdit/profileEdit.html y subscribirse al usuario correspondiente. Al igual que los demás recursos de edición, éste mantiene el diseño base (figura \ref{fig:editFormBase}), es decir, que incorpora la plantilla \{\{$<$awesomeForm\}\} la cual, mediante una variable de sesión, carga uno u otro formulario con características comunes. En este caso, el formulario de edición dinámico creado en el prototipo 4. Además incorporamos los componentes avatar, banner y description (figuras \ref{fig:profileEdit}, \ref{fig:formEditComplements}). 
\subsection{Contactos}
Al existir usuarios en la aplicación es necesario establecer y denominar las relaciones entre ellos. Dichas relaciones se denominan relaciones de contacto. Con esto surge una nueva entidad (Contactos) que se traduce en una nueva colección Mongo llamada Relations con su fichero correspondiente y cuyo objeto es \ref{relationMongo}


\subsubsection{Peticiones y lista de contactos}
Surge una nueva entidad Peticiones que se traduce en la colección llamada Requests cuyo objeto es \ref{requestsMongo} 
Para el \{\{contentTab\}\} del tab 'contactos' \ del \{\{navbarTab\}\} de la página de perfil se establecen dos nuevas tabs: contactos y peticiones.
\paragraph{}
Para la tab contactos activa se mostrará la lista de los contactos (figura \ref{fig:contactsTab}). Cada miniatura contará con el avatar, el nombre de usuario, la fecha desde la que se inició la relación de contacto, la descripción y acciones (sólo visibles cuando el usuario es el propietario del perfil).

\paragraph{}
Para la tab peticiones activa se mostrará el espacio para peticiones (figura \ref{fig:requestsTab}). Dicho espacio esta compuesto por: 
\begin{itemize}
	\item Autocompletado: para buscar los usuarios. Cada resultado dispondrá de un botón para enviar la petición. Este botón se sustituirá por iconos de estado si la petición ya ha sido realizada. 
	\item Bandeja de entrada: se muestran las peticiones recibidas, su estado y acciones relacionadas con su estado.
	\item Bandeja de salida: se muestran las peticiones enviadas, su estado y acciones relacionadas con su estado.
\end{itemize}

Las acciones dependiendo del estado y de la bandeja en la que se encuentren se muestran en la tabla \ref{tabla:requestsActions}: 

\begin{table}[htb]
\centering
\begin{tabular}{|l|l|l|}
\hline
& \multicolumn{2}{c|}{Acciones} \\
\hline
Estado & Recibidas & Enviadas\\
\hline
Pendiente & Aceptar o Rechazar & X\\ \hline
Aceptada & Ok & Ok\\ \hline
Rechazada & X & Ok o Reenviar \\ \hline
\end{tabular}
\caption{Acciones para las peticiones}
\label{tabla:requestsActions}
\end{table}

El proceso para establecer la relación de contacto es la siguiente: 
\begin{enumerate}
	\item El usuario A envía una solicitud al usuario B y visualiza esta petición como pendiente.
	\item El usuario B visualiza la petición como pendiente en su bandeja de entrada y puede aceptarla o rechazarla.
	\item El usuario B acepta la petición y la visualiza como aceptada, pulsa Ok. Se crea la relación.
	\item El usuario A visualiza la petición como aceptada, pulsa Ok para eliminar la entrada.
\end{enumerate}

\paragraph{}Si el usuario B rechaza la petición, el usuario A la visualizaría como rechazada y podría pulsar Ok o reenviarla y comenzar el proceso de nuevo.

\paragraph{}Además de realizar las peticiones mediante este espacio, se habilita para los usuarios que tengan el rol de visitante un botón en \{\{actions\}\} como se muestra en la figura (\ref{fig:profileBanner}).

\paragraph{}La implementación de este prototipo tiene como resultado las figuras (tal tal tal en apéndices).


\section{Prototipo 7: Conversaciones y alertas}
En este prototipo se ha diseñado y desarrollado el módulo de comunicaciones interno de la aplicación basado en conversaciones o chats. También el sistema de alertas y avisos de nuevos mensajes.
\subsection{Conversaciones}
\subsubsection{Entidades, Rutas, subscripciones y publicaciones}
Se trata de otra categoría de contenidos dentro de la aplicación por lo que tendrá un recurso de creación, de detalle y de edición: /conversation/submit, /conversation/:\_id y /conversation/:\_id/edit. El acceso a las conversaciones es privada, es decir, sólo los miembros pueden visualizarlas. Esto se traduce en que el listado de las mismas está disponible como contenido dentro del recurso perfil de cada usuario y sólo será visible si el usuario tiene el rol de propietario.
\paragraph{}
Con la aparición de esta nueva categoría surgen las nueva entidades Conversaciones y Mensajes que se traducen en las colecciónes Conversations (/app/lib/collections/conversations.js) y Messages (/app/lib/collections/messages.js) y cuyos objetos se definen en \ref{conversationMongo} y \ref{messageMongo}. La relación de éstas con las demás entidades queda reflejada en la figura (tal).
\paragraph{}
Al igual que para las anteriores categorías, se han creado las publicaciones necesarias a las que nos subscribiremos mediante Iron Router en las rutas establecidas a los recursos de detalle y de edición.
\subsubsection{Roles}
Los roles en las conversaciones serán importantes a la hora de ofrecer a los usuarios diferente funcionalidad. Los miembros de una conversación se pueden clasificar según sus roles en:
\begin{itemize}
	\item \textbf{Líder: } tiene acceso a todas las características de la conversación. Podrá expulsar usuarios, cambiar el asunto, añadir a nuevos miembros como invitados e, incluso, delegar su rol a otro miembro.
	\item \textbf{Invitados: } éstos tendrán acceso a las mismas funciones que el líder a excepción de expulsar usuarios y de cambiar el asunto.
\end{itemize}
\subsubsection{Creación de una conversación}
Puesto que las conversaciones son privadas, el único medio para acceder a su recurso de creación es desde el recurso perfil. Al igual que los anteriores, este recurso utiliza la plantilla \{\{$<$awesomeForm\}\} que mediante la variable de sesión 'typeForm' incluirá la plantilla base para un formulario de edición. Esta plantilla incorporará los componentes correspondientes para la introducción de la información necesaria. Estos son una caja de texto para el asunto y dos complementos que se han implementado para la introducción de miembros y del primer mensaje (figura tal).

\subsubsection{Página de conversación}
Este será el primer y único recurso de detalle que no compartirá con los demás el diseño base formado por un \{\{banner\}\}, \{\{navbarTab\}\} y \{\{contentTab\}\}. El diseño corresponderá al mostrado en la figura (tal) que se compone de tres espacios: 
\begin{itemize}
	\item \textbf{Cabecera: } aquí se mostrará toda la información relevante de la conversación (asunto, lista de miembros, contadores), botones para para visualizar el panel de miembros, el panel de opciones y acceder al recurso de edición.
	\item \textbf{Cuerpo: } corresponde a la lista de mensajes de la conversación. Los escritos por el usuario actual aparecerán a la derecha y los de los demás miembros a la izquierda. Cada mensaje poseerá información sobre su autor (nombre de usuario y avatar) y la fecha en la que se escribió.
	\item \textbf{Footer: } en este espacio aparecerá una caja de texto para la introducción de mensajes, unos botones para visualizar la lista de emoticonos y la introducción de enlaces y un botón para enviar. 
\end{itemize}
\paragraph{}
En el panel de miembros podremos ver la lista completa de usuarios que tienen accesible la conversación y acceder a sus perfiles.
\paragraph{}
El panel de opciones se adaptará al rol del usuario correspondiente. Las acciones disponibles son: editar, añadir más usuarios, borrar el historial de mensajes, expulsar miembros y dejar la conversación.
\paragraph{}
Partiendo del hecho de que las conversaciones deben tener un líder, si un usuario con este rol decide dejar la conversación deberá delegar su rol a otro miembro y después salir.
\subsubsection{Edición de una conversación}
Para este recurso se utilizará el mismo diseño de plantillas que para los anteriores recursos de edición. El formulario diseñado para este recurso (figura tal) integrará nuevos componentes: 
\begin{itemize}
	\item \textbf{\{\{subjectEdit\}\}: } complemento para editar el asunto.
	\item \textbf{\{\{leaderEdit\}\}: } permite escoger entre los miembros de la conversación al nuevo líder.
	\item \textbf{\{\{membersEdit\}\}: } permite editar los miembros (añadir y borrar).
\end{itemize}
El diseño de estos componentes o complementos puede verse en la figura (tal).
\subsection{Alertas}
\subsubsection{Concepto y entidades}
Partiendo del requisito de que los usuarios deben estar informados en todo momento de lo que ocurre en las conversaciones, se ha desarrollado un módulo de alertas de conversación. Estas alertas se generarán en el momento que se introduzca un nuevo mensaje en cualquier conversación y se mostrarán a todos aquellos usuarios miembro que no se encuentren visualizando la página de dicha conversación. El espacio dedicado a la visualización de las distintas alertas será una pestaña del sidebar (figura tal). De este modo los usuarios podrán visualizarlas en cualquier momento. 
\paragraph{}
Este concepto supone una nueva entidad llamada Alertas de Conversación que se traduce en la colección conversationAlerts (/app/lib/collections/conversationAlerts.js) cuyo objeto MongoDB se muestra en \ref{conversationAlertMongo}. La relación de esta entidad con las anteriores puede verse en el esquema de la figura (tal). 
\paragraph{}
\subsubsection{Proceso}
Al crearse una conversación se generan tantas alertas como miembros posea y su atributo alertsAllow tendrá un valor inicial de true. 
En el momento que un miembro accede a la conversación ese atributo se tornará a false. Creamos una publicación a la que los usuarios estarán subscritos en todo momento. Se basa en publicar las alertas de conversación que tengan el atributo alertsAllow a true. Además contará con la referencia a la conversación de la que proceden por lo que para cada alerta se mostrará el último mensaje.
\paragraph{}
El siguiente código muestra un ejemplo de implementación de este proceso.

\begin{lstlisting}[language=Javascript]
//app/client/modules/conversation_modules/conversation/conversation.js
Template.conversation.events({
	'click #send-new-message': function(){
		Meteor.call('insertMessage');
		//actualizamos el contador de alertas y establecemos el ultimo mensaje
		Meteor.call('updateAlertsConversation',this._id,Meteor.userId());
	}
});
Template.conversation.rendered = function(){
	//actualizamos la visualización de las alertas y el contador.
	Meteor.call('updateAlertsConversation',this._id, Meteor.userId(),function(err){
		if (err) throw new Meteor.Error ('ERROR: updateAlertsConversation');
	});
}

//app/lib/router.js
Router.configure({
	//el usuario estará subscrito a sus alertas en todo momento.
	waitOn: function(){
		...
		return Meteor.subscribe('conversationAlerts',Meteor.userId());
	}
});
\end{lstlisting}


\section{Prototipo 8: Emails e integración de servicios de registro}
En este prototipo se ha implementado un módulo de mensajería, los procesos de verificación de email, cambio y recuperación de contraseña para los usuarios y se han introducido nuevos servicios con los que realizar el registro en la aplicación partiendo de los requisitos correspondientes (ver \ref{sec:requisitos}).
\subsection{Verificación de Email, cambio y recuperación de contraseña}
\subsubsection{Proceso de verificación}
Este servicio será exclusivo para los usuarios que posean un email asociado a su cuenta y será accesible desde el perfil como puede verse en la figura \ref{fig:profileBanner}.
\paragraph{}
El proceso es muy simple. El usuario escoge que email verificar y hace click en verificar. En ese momento se enviará un correo con el link de verificación. En Meteor gracias al paquete Accounts podremos configurar la plantilla de los correos que enviemos desde la aplicación. Deberemos especificar una dirección de correo como origen y el cuerpo del mensaje. Para ello se ha generado la dirección duckflight.team@gmail.com. El cuerpo del mensaje accepta un parámetro que corresponde con el link de verificación en este caso. Hacemos uso de Meteor.absoluteUrl() para extraer el dominio base de nuestro sitio y después modificamos la url de forma que coincida con la ruta establecida en Iron Router /verify-email/:\_token. 
\paragraph{}
Para enviar el mensaje utilizamos el método .sendVerificationEmail al que le pasamos como parámetro la dirección de correo y el identificador del usuario. Este método sólo está accesible en el paquete Accounts en el cliente por lo que se crea un method en el lado del servidor. En el momento que un nuevo usuario es creado junto con una dirección de correo, también se llamará a este método para que el usuario pueda desde el primer momento acceder a las funcionalidades que brinda el tener un email verificado dentro de la aplicación.
\paragraph{}
En el momento que el usuario explore su bandeja de entrada y pinche en el link de verificación se llamará al método .verifyEmail de Accounts en el lado del cliente. El único parámetro que necesita es el token del link que lo tiene accesible gracias a Iron Router que lo ha incluido como datos de la plantilla.
\begin{lstlisting}[language=Javascript]
//app/server/accounts
Meteor.methods({
	sendVerificationLink: function(address,user_id){
		Accounts.sendVeriicationEmail (address,user_id);
	}
});

//app/client/verifications/verificationEmail.js
Template.verificationEmail.events({
	'click button.verify': function(){
		Meteor.call('sendVerificationLink',this.address,Meteor.userId());
	}
});

Template.verifyEmail.rendered = function(){
	Accounts.verifyEmail(this.data.token);
}

//app/lib/router.js
Router.route('/verify-email/:_token',{
	name: 'verifyEmail',
	data: function(){
		return {
			token: this.params.token;
		}
	}
});
\end{lstlisting}
El código anterior muestra un esquema de la implementación.
El diseño de las interfaces puede verse en las figuras tal y tal.

\subsubsection{Proceso de cambio de contraseña}
Este servicio será exclusivo para los usuarios que se hayan registrado mediante un nombre de usuario y contraseña y estará accesible desde el perfil como puede verse en la figura \ref{fig:profileBanner}.
\paragraph{}
El proceso es muy sencillo. Primero el usuario deberá introducir su contraseña actual (si la ha olvidado podrá iniciar el proceso de recuperación a través de un enlace). Después de comprobar que es correcta, el usuario podrá introducir una nueva contraseña y actualizarla. Mediante el paquete Accounts podremos utilizar los métodos .checkPassword (desde el servidor) y .changePassword (desde el cliente) para este proceso.
\begin{lstlisting}[language=Javascript]
//app/client/modules/changePassword/changePassword.js
Template.changePassword.events({
	'click #check': function(e,template){
		var pwToCheck = template.find('[name=oldPassword]')
		Meteor.call('checkPassword',pwToCheck, Meteor.userId(),function(err,res){
			if (!err) Session.set('oldPassword',pwToCheck);
		});
	},
	'click #update-password': function(e,template){
		var password = template.find('[name=password]');
		var repassword = template.find('[name=repassword]');
		if (password == repassword){
			Accounts.changePassword (Session.get('oldPassword'),password,Meteor.userId());
		}
	}
});
El diseño de las interfaces de este proceso se muestran en las figuras (tal)
\end{lstlisting}
\subsubsection{Proceso de recuperación de contraseña}
Este servicio al igual que el de cambio de contraseña será exclusivo de los usuarios registrados con contraseña. Será accesible desde el proceso de cambio de contraseña y desde el formulario de inicio de sesión (figura \ref{fig:signIn}).
\paragraph{}
El proceso es similar al de verificación de email sólo que los métodos son: .sendResetPasswordEmail (en el lado del servidor) y resetPassword (e el lado del cliente). Como el proceso requiere el envío de un email habrá que establecer la configuración de su plantilla de la misma forma que para el proceso de verificación.

El diseño de las interfaces pueden verse en las figuras (tal y tal).


\subsection{Distribuidor y parámetros globales}
Para el envío de correos mediante la aplicación es necesario un cliente de mensajería o distribuidor. Para este proyecto hemos usado el servicio que nos proporciona mailgun \footnote{\url{https://mailgun.com}}. Se trata de una herramienta que nos proporciona un dominio de correo propio que añadido como variable de entorno de nuestra aplicación, se encargará de la aceptación y la distribución de nuestros correos. 
\begin{lstlisting}[language=javascript]
Meteor.startup(function(){
	process.env.MAIL_URL = 'nombre_de_dominio_de_mailgun'
});
\end{lstlisting}
\paragraph{}
Para usar este servicio ha sido necesaria la creación de un usuario en mailgun y la elección de uno de los paquetes ofertados. En este caso se ha optado por el paquete gratuito. Aunque los correos tardan en distribuirse funciona de forma aceptable.

\subsection{Envío de emails desde la aplicación}
Meteor posee un paquete por defecto para esta funcionalidad: el paquete Email. Mediante su método .send() podremos enviar cualquier email. Este método acepta un objeto con los parámetros to, from y html para establecer el destino, origen y cuerpo del email.
\subsubsection{Proceso de envío}
El proceso sigue dos fases: elección del correo a utilizar como origen y la composición del mensaje, en la que estableceremos las direcciones de destino, el asunto y el cuerpo. 
\paragraph{}
Si el usuario no tiene ningún email verificado aparecerá un enlace al recurso de verificación de emails. 
Para la introducción de las direcciones de destino utilizamos el complemento diseñado para introducir los miembros de una conversación en el recurso de creación y de edición de la misma. 
Para la composición del cuerpo del mensaje hemos utilizado un editor de textos enriquecido llamado froalaEditor y que lo tenemos disponible como paquete Meteor (froala:editor).
Las interface pueden verse en las figuras (tal y tal).
\subsection{Integración de servicios de registro}
Para este proyecto vamos a incluir además del sistema de registro basado en nombre de usuario y contraseña, otros servicios como el de registro mediante Google, Github y Facebook.
\paragraph{}
Para cada uno de los anteriores ha sido necesaria la creación de una app en el espacio para desarrolladores correspondiente a cada sitio y la configuración de los servicios mediante la introducción de los parámetros de autenticación proporcionados para cada aplicación. La configuración de los servicios se ha realizado usando el paquete ServiceConfiguration de la forma: 
\begin{lstlisting}[language=Javascript]
	ServiceConfiguration.configurations.remove({
	service: 'google'});
	ServiceConfiguration.configurations.insert({
		service: 'google',
		client_id: '//identificador de la aplicación',
		secret: '//clave secreta de la aplicación',
		redirect_uri: '//url de redirección'.
	});
\end{lstlisting}
Para cada uno de los servicios incluimos los paquetes loginWith<service>. Esto hará que tengamos el método .loginWith<service> disponible en el paquete Accounts.

Por último añadimos botones al formulario de inicio de sesión para ofrecer la posibilidad de registrarse a través de estos servicios (figura tal)

\section{Prototipo 9: Página principal y sistema de búsqueda}
En este prototipo se diseñará e implementará el contenido de la página principal de la aplicación y el sistema de búsqueda desarrollado.
\subsection{Estructura}
\begin{figure}[htpb]
	\centering
	\includegraphics[width=0.8\textwidth]{mainPage.png}
	\caption{Diseño de la página principal}
	\label{fig:mainPage}
\end{figure}
En esta página según los requisitos debe existir un espacio para recomendaciones y otro para mostrar los contenidos más populares o votados. Por lo que esta va a se la estructura de la información de la página. 
\paragraph{}
Además incluiremos un \{\{navbarTab\}\} con las tabs Home y Search para acceder al contenido principal o al buscador como puede verse en la figura \ref{fig:mainPage}.
\paragraph{}
El contenido principal se estructura en tres bloques: 
\begin {itemize}
	\item \textbf{Módulo de tareas iniciales:} este módulo impondrá al usuario una serie de tareas categorizadas que le ayudarán a establecer un primer contacto con la aplicación.
	\item \textbf{Relacionados:} este espacio estará categorizado según los tres grandes categorías de contenido de la aplicación (grabaciones,canales y lecciones). Los contenidos se mostrarán como un carousel de miniaturas. Se mostrarán los contenidos que compartan las tags que posean los contenidos votados por el usuario. De esta forma se oferta contenido relacionado a los gustos del usuario.
	\item \textbf{Populares:} aquí se muestran los contenidos más populares del momento. Su representación es idéntica que la del espacio anterior.
\end{itemize}

\subsection{Sistema de búsqueda basado en modificadores}
Para hacer las búsquedas más rápidas y precisas se ha implementado un sistema de búsqueda basado en modificadores. De manera que con solo introducir el carácter + en el cuadro de búsqueda el sistema nos sugiera modificadores.
\paragraph{}
Los modificadores disponibles son: 
\begin{itemize}
	\item \textbf{+category: } los posibles valores son recordings, channels, lessons y all. Establece el tipo de contenido a buscar.
	\item \textbf{+author: } nos irá sugiriendo usuarios mediante un auto-completado. Establece el autor de los contenidos.
	\item \textbf{+sort: } los posibles valores son latest y popular. Sirve para ordenar los resultados según estos filtros.
	\item \textbf{+tag: } se trata de un auto-completado de etiquetas. Establece las etiquetas que poseerán los resultados.
	\item \textbf{+from: } sólo disponible cuando la categoría corresponde a recordings. Los posibles valores son lesson o channel. Establecen la procedencia de las grabaciones a buscar.
	\item \textbf{+subscribed: } los valores son subscribed o unsubscribed. Sólo disponible si la categoría corresponde a lessons o channels. Establece el estado de subscripción del usuario en los contenidos.
\end{itemize}
\paragraph{}
Los resultados se clasifican según las categorías en un sistema de tabs. Para cada categoría se muestra el número de resultados. 
\paragraph{}
La implementación de este módulo integra una plantilla llamada \{\{<smartSearch\}\} que utiliza un objeto creado mediante el constructor SearchParamsManager creado en /app/client/lib/searchParamsManager.js. Dicho objeto se encarga traducir los actuales modificadores introducidos en parámetros de búsqueda o de subscripción para Mongo. Una vez traducidos procede a la subscripción de las publicaciones correspondientes. En este caso se han creado tres, una por categoría y mediante el valor del modificador +category filtra las subscripciones. Además se han creado plantillas de auto-completado para los modificadores y para la lista de sugerencias de cada uno.
\paragraph{}
La interfaz puede verse en la figura (tal).
\section{Prototipo 10: Página de inicio y módulos adicionales}
En este prototipo se ha implementado el apartado descriptivo de la aplicación. Este comprende el desarrollo de la página de inicio, los espacios para tutoriales y features y un módulo de ayuda. El resultado de esta implementación puede verse en las figuras tal tal tal y tal.
\subsection{Página de inicio}
Se ha querido que la página de inicio sea lo más descriptiva posible en lo que respecta a las características de la aplicación y su funcionalidad. Por lo que se ha diseñado en secciones. En cada sección se introducirá una característica y se mostrará un enlace al recurso /features correspondiente a la misma. También se ha creado una sección introductoria a los tutoriales con un enlace al recurso /tutorials.
\subsection{Espacio para tutoriales}
No es necesario que los usuarios estén autenticados en el sitio para tener acceso a este espacio. Se ha creado un recurso /tutorials cuya layout es similar al principal. Está formado por un sidebar y un header. El sidebar tiene sólo un menu. El menú está estructurado en secciones y cada sección contiene una lista de tutoriales. Los tutoriales serán videos que explicarán cómo realizar diversas funciones dentro de la aplicación. Además, para que sea más accesible, cada tutorial tendrá una url. Esto se ha hecho mediante query strings que indican la sección y el tutorial concreto que se desea visualizar. Se ha habilitado también un enlace en el sidebar de la aplicación para acceder a este recurso en una nueva pestaña.
\subsection{Espacio para features}
En este espacio se resumirán todas las características y funcionalidades de la aplicación. Al igual que para el espacio de tutoriales se crea un recurso /features que será accesible para todos los usuarios y el layout es idéntico. Aunque el contenido varía. El contenido de cada feature está formado por una cabecera en la que aparece una imagen descriptiva y el título y un cuerpo en el que se muestra una galería de imágenes. Al hacer click en cada imagen podremos visualizarla en pantalla completa, leer su descripción y navegar por las que conforman la galería. También se ha habilitado un enlace a este recurso en el sidebar de la aplicación.
\subsection{Módulo de ayuda flexible}
Este módulo está formado por un botón y un collapsible de Bootstrap. Al hacer click en el botón se despliega una lista de preguntas frequentes que podemos editar y configurar vía javascript para poder adaptar las preguntas al contexto de la página en la que incluyamos dicho módulo. Cada pregunta es un enlace a uno de los tutoriales. 
\section{Prototipo Final: Notificaciones y restricciones de acceso}
En este prototipo se ha implementado el módulo de notificaciones y las plantillas \{\{notFound\}\} y \{\{accessDenied\}\}.
\subsection{Notificaciones}
Partiendo del requisito de que los usuarios deben estar informados en todo momento de cualquier cambio de su interés dentro de la aplicación surge la entidad de Notificaciones y con ella la colección Notifications (/app/lib/collections/notifications.js) cuyo objeto MongoDB será el mostrado en \ref{notificationMongo}.
\paragraph{}
Las notificaciones se visualizarán en una pestaña del sidebar como se muestra en la figura \ref{fig:sidebarNotifications}


Las notificaciones en el sidebar estarán categorizadas por: canales, lecciones, grabaciones, conversations y contactos. Cada categoría se mostrará como un desplegable con la lista de las notificaciones correspondientes. Éstas podrán borrarse todas de una vez o independientemente. Al hacer click en cualquiera de ellas la aplicación navegará al contexto de la misma y la eliminará de la base de datos. Puesto que es un contenido accesible en todo momento, incluiremos la subscripción a la publicación que hemos desarrollado a la configuración global de Iron Router:

\begin{lstlisting}[language=Javascript]
Router.configure({
	waitOn: function(){
		var subs = [
			Meteor.subscribe('conversationAlerts',Meteor.userId()),
			Meteor.subscribe('notifications',Meteor.userId())
		];
		return subs;
	}
})
\end{lstlisting}
\paragraph{} 
Para la creación de las notificaciones se ha desarrollado el constructor NotificationsCreator (/app/client/lib/notificationsCreator.js) del cual se genera una instancia nada más arrancar el cliente. Este objeto posee el método público .createNotification que acepta los parámetros necesarios para su correcta creación. Según su tipo y su contexto generará un mensaje distinto. 
\paragraph{}
Las notificaciones cubren la mayoría de eventos en la aplicación entre los que destacan: el voto a los contenidos, los comentarios, la creación de contenido en canales y lecciones a los que el usuario se ha subscrito, cambios de usuarios en una conversación, creación de respuestas a grabaciones y peticiones de contacto.

\begin{figure}[htpb]
	\centering
	\includegraphics[width=0.7\textwidth]{sidebarNotifications.png}
	\caption{Diseño de la pestaña de notificaciones en el sidebar}
	\label{fig:sidebarNotifications}
\end{figure}

\subsection{Recursos de error}
\subsubsection{404}
El error 404 es devuelto por el servidor cuando los datos a los que intentamos acceder no existen. Esto puede deberse al acceso mediante url de algún recurso que ya no exista. Debe controlarse y se hace creando la plantilla \{\{$<$notFound\}\} (figura tal). Necesitamos utilizarla en dos posibles situaciones: 
\begin{itemize}
	\item El usuario accede a un recurso que cuyos datos han sido borrados, pero el recurso es válido.
	\item El usuario accede a un recurso inválido.
\end{itemize}
Los casos anteriores pueden ser controlados mediante Iron Router. El primero mediante el plugin 'dataNotFound' y el segundo mediante una nueva ruta colocada al final de todas las creadas y que acepte cualquier recurso. El siguiente código ilustra la configuración mencionada: 
\begin{lstlisting}[language=Javascript]
Router.plugin('dataNotFound',{template: 'notFound'});
Router.route('/(.*)',{name: 'notFound'});
\end{lstlisting}
\subsubsection{Access Denied}
Si bien la aplicación no permite el acceso a contenidos privados para el usuario mediante el flujo diseñado, si que es posible alterar las urls para navegar al recurso privado, por lo que esto debe de controlarse.
\paragraph{}
Para ello se ha creado la plantilla \{\{$<$accessDenied\}\} (figura tal), la cual se muestra cuando un usuario intenta editar algún recurso detalle del cual no es autor. Esto se consigue mediante los hooks de Iron Router, en concreto el hook beforeAction. He aquí un ejemplo: 
\begin{lstlisting}[language=Javascript]
Router.route('/profile/:_id/edit',{
	...
	beforeAction: function(){
		if (Meteor.userId() !== this.params.id){
			this.render('accessDenied');
		}else{
			this.next();
		}
	}
});
\end{lstlisting}

\section{Despliegue}
El despliegue se ha llevado a cabo mediante el sistema de Hosting de Heroku. 

\subsection{Primeros pasos}
Para realizar este despliegue el primer paso ha sido crear una cuenta en heroku y descargar el CLI para poder desplegar nuestra aplicación de forma remota. El despliegue en Heroku se basa en una idea muy simple. El despliegue es tan sencillo como almacenar una nueva versión de tu repositorio local en el repositorio remoto en github. El siguiente paso, una vez autenticado mediante el comando del CLI heroku login, creamos una aplicación a la que damos el nombre de duckflight. Acto seguido nos devuelve dos urls que corresponden a dos repositorios remotos de github. Esa url la añadiremos como repositorio remoto al actual.
\paragraph{}
Ahora necesitamos una base de datos remota, ya que hasta ahora habíamos trabajado con la base de datos que nos creaba Meteor. Para ello creamos un sandbox en mlab mediante el CLI de heroku. Esto nos devolverá la url de la base de datos que deberemos atribuir como parámetro global a la aplicación duckflight. 
\paragraph{}
Finalmente necesitamos un paquete constructor que se encargue de identificar que se trata de una aplicación de Meteor y de generarla en la url en la que se hará el despliegue. Dicho paquete es jordansissel:heroku-buildpack-meteor y se configura mediante el comando heroku create --buildpack <buildpack>. 
\paragraph{}
Una vez seguidos estos pasos, procedemos al despliegue de la aplicación mediante el comando git push heroku master.
\subsection{Proceso}
En el momento que ejecutamos el comando anterior se crea una copia de nuestro repositorio local en el repositorio remoto heroku. Acto seguido el buildpack o paquete constructor se encarga de generar nuestra aplicación y de arrancarla en la url correspondiente.
\subsection{Pruebas globales}
Una vez realizado el despliegue se han llevado ha explotado la funcionalidad de la aplicación de forma que se han probado todas las características de la misma. El resultado de estas pruebas ha sido satisfactorio.
