\chapter{Diseño y desarrollo de la aplicación}
\section{Tipo de Arquitectura}
\paragraph{}
El modelo de arquitectura más habitual es el \textbf{MVC} (Modelo Vista Controlador) (figura \ref{fig:mvcpattern}). El modelo correspondería con la arquitectura de base de datos y el diseño de la misma, la vista son las interfaces o plantillas que se muestran al usuario y el controlador es el encargado de dotar a la aplicación de lógica y funcionalidad. Existen otros tipos de arquitectura tales como \textbf{MVVM} (figura \ref{fig:mvvmpattern}), donde el controlador del patrón MVC se sustituye por VM o \emph{ViewModel} que establece que cada vista posee lógica y un sistema de \emph{data-binding} entre plantillas.

\begin{figure}[htbp]
    \centering
    \subfigure[Patrón de arquitectura MVC]{
   	 \includegraphics[width=1\textwidth]{mvc.png}
    	\label{fig:mvcpattern}
    }
    \subfigure[Patrón de arquitectura MVVM]{
    	\includegraphics[width=1\textwidth]{mvvm.png}
	 \label{fig:mvvmpattern}
    }
    \caption{Patrones de arquitectura}
    \label{fig:patterns}
\end{figure}

\paragraph{}
La elección del patrón de arquitectura a usar es importante puesto que esa decisión nos limitará a la hora de usar determinadas herramientas.
\paragraph{}

\section{Búsqueda de herramientas}
\paragraph{}
Partiendo de los requisitos establecidos que caracterizarán la aplicación podemos afirmar que necesitamos encontrar herramientas que nos permitan construir una aplicación en tiempo real, realizar grabaciones de audio, una interfaz con UX (User eXperience) como parámetro fundamental y que trabaje de manera óptima.

\subsubsection{Aplicación en tiempo real y prototipado rápido}
\paragraph{}
Necesitamos algún framework o plataforma que trabaje con el concepto de reactividad o que lo simule. Elegimos MeteorJS por su flexibilidad, su asombroso concepto de reactividad y por su patrón de trabajo que engloba el desarrollo del cliente y del servidor. Debido a esta elección utilizaremos MongoDB como tecnología de base de datos y MVVM como patrón de arquitectura de la aplicación.
\paragraph{}
Para el enrutamiento es precisa otra herramienta que nos proporcione la funcionalidad de especificar a qué recurso pertenece una plantilla y que datos asociamos a ella. Para ello existen varios paquetes para Meteor que realizan este proceso como IronRouter o FlowRouter. Ambos igual de válidos pero para este proyecto se ha optado por IronRouter, ya que dispone de mayor documentación.
\paragraph{}
Para el concepto de publicaciones y subscripciones de Meteor usaremos publishComposite, un paquete que permite realizar publicaciones compuestas (varias colecciones con relación de dependencia reactiva) y que siguen manteniendo el principio de reactividad y optimizando nuestro sistema de subscripciones. Sin este paquete realizar esta labor es más compleja. 

\subsubsection{Grabaciones de audio}
\paragraph{}
Existen numerosas formas de grabar audio vía web y algunas API de sitios como SoundCloud incorporan un grabador de audio directamente. Aunque esta hubiera sido la vía más rápida, la verdad es que no habría sido la más flexible, ya que el hacerlo de esta manera requería que el uploading se efectuara en SoundCloud. Por este motivo se ha utilizado la tecnología de WebRTC para esta tarea y construido un grabador modular que puede incorporarse fácilmente a otros proyectos y que además si se desea usar el servicio de hosting de SoundCloud seguiría siendo factible. 

\subsubsection{Hosting o Almacenamiento}
\paragraph{}
Utilizaremos el servicio de hosting de SoundCloud para almacenar el audio de nuestras grabaciones. No es lo más sensato para una aplicación real y comercializable puesto que existen restricciones en lo que corresponde a capacidad, pero para nuestra aplicación es más que suficiente. 

\subsubsection{Interfaz con UX como parámetro de diseño fundamental}
\paragraph{}
Partiendo del requisito de que la aplicación debe ser atractiva al usuario y no sólo en términos visuales sino en eficacia a la hora de gestionar acciones, en este proyecto nos hemos decantado por el framework front-end Bootstrap para la maquetación y por la tecnología Flexbox para dotar de flexibilidad a las plantillas. Además utilizaremos SASS como preprocesador de CSS con el fin de optimizar nuestra arquitectura de estilos mediante un paquete para Meteor.


\section{Composición Inicial y entorno de desarrollo}
\paragraph{}
Una vez realizada la búsqueda de herramientas comenzamos a componer el entorno de nuestra aplicación. Para este proyecto utilizaremos el programa WebStorm de JetBrains. Incorpora herramientas de búsqueda y sustitución avanzada, terminal para comandos, integración con sistema de control de versiones Git y plugins que facilitan la labor de desarrollo como elmet.
\subsection{Primeros pasos}
\paragraph{}
Gracias al CLI de Meteor generamos nuestra aplicación mediante el comando: \emph{meteor create $<$AppName$>$}. Esto nos genera una carpeta con tres ficheros: index.html, index.js e index.css. En este momento ya tenemos nuestra aplicación Meteor creada. 
\paragraph{}
Ahora debemos estructurar nuestra aplicación según la jerarquía mostrada en la figura \ref{fig:hierarchyFolders} creando los ficheros y carpetas necesarios.

\paragraph{}
Una vez estructurada la aplicación instalamos los paquetes iniciales mediante el comando: \emph{meteor add $<$ PackageName$>$}. La lista de paquetes iniciales es la siguiente: 
\begin{itemize}
\item \textbf{accounts-base:} paquete base para cuentas de usuario.
\item \textbf{accounts-password:} contraseña como servicio de registro de usuarios.
\item \textbf{fortawesome:fontawesome:} biblioteca de iconos.
\item \textbf{fourseven:scss:} preprocesador Sass para estilos.
\item \textbf{iron:router:} paquete para enrutamiento.
\item \textbf{mizzao:bootstrap-3} maquetación.
\item \textbf{reywood:publish-composite:} publicaciones avanzadas y compuestas.
\end{itemize}

\subsection{Mixins}
\paragraph{}
SASS nos permite crear reglas dinámicas de estilos que poder incluir en cualquier clase llamados mixins. Para este proyecto hemos utilizado este concepto para la labor de cross-browsing. Esta labor se basa en la traducción de una misma regla a los distintos navegadores Web, ya que cada navegador interpreta algunas reglas de forma distinta. Por lo que estos mixins nos permiten unificar diferentes reglas que se interpretan de manera distinta dependiendo del navegador. Un ejemplo de mixin es el siguiente: 
\begin{lstlisting}[caption=Mixin border-radius, label={mixinEj}]
@mixin border-radius($radius){
	-webkit-border-radius: $radius;  #safari, chrome
	-moz-border-radius: $radius; #mozilla firefox
	-ms-border-radius: $radius; #Internet Explorer
	border-radius: $radius; #new
}
\end{lstlisting}
\paragraph{}
Creamos un fichero con el nombre de \_mixins.scss dentro de la carpeta client al nivel del fichero index.html. El carácter \_ indica al preprocesador que esta hoja de estilos no la debe procesar. El procesado lo realizará en el momento que la importemos a otra hoja de estilos e incluyamos algún mixin.
Los mixins más utilizados en este proyecto serán los siguientes: border-radius, flexbox (flex, flex-direction, flex-wrap, etc), opacity, transition, animation y gradient. El archivo está disponible en el repositorio de GitHub.
\section{Prototipo 1: Registro de usuarios y layout principal}
\paragraph{}
Este es el primer prototipo de la aplicación y se corresponde con el layout principal de la aplicación y con el registro de usuarios. 
\subsection{Layout principal}
\begin{figure}[htbp]
    \centering
    \subfigure[Large layout]{
   	 \includegraphics[scale=0.42]{layoutLarge.png}
    	\label{fig:layoutLg}
    }
    \subfigure[Small Layout]{
    	\includegraphics[scale=0.42]{layoutSmall.png}
	 \label{fig:layoutSm}
    }
    \caption{Diseño de Layout Full-responsive}
    \label{fig:layoutFR}
\end{figure}
Iron Router establece que el diseño de la aplicación debe realizarse en torno a dos plantillas: \{\{yield\}\} y \{\{layout\}\}. El layout es la plantilla genérica y el yield es el contenido. Como puede verse en la figura \ref{fig:layoutFR}, ésta va a ser la estructura genérica de nuestra aplicación: 
\begin{itemize}
	\item \textbf{Layout: } estará compuesta por un sidebar, un header y la plantilla yield.
	\item \textbf{Yield:} esta plantilla es dinámica y se podrá asignar una plantilla u otra dependiendo de la ruta en la que nos encontremos.
\end{itemize}
\paragraph{}
Partiendo del requisito de que los usuarios deben estar autenticados para acceder a la funcionalidad de la aplicación es necesario diseñar el flujo de registro de usuario y situarlo en un recurso o ruta. Debido a esta restricción el flujo se situará en el recurso raíz (/). Por lo que, dependiendo de si el usuario está autenticado o no al acceder a esta ruta deberá mostrarse una plantilla u otra. En este caso:
\begin{itemize}
\item Si el usuario está autenticado el layout estará compuesto por la plantilla \{\{$<$sidebar\}\},  \{\{$<$header\}\} y la plantilla \{\{$<$yield\}\} que corresponderá a la plantilla \{\{$<$startPage\}\}.
\item  Si el usuario no está autenticado el layout estará compuesto solamente por la plantilla \{\{$<$yield\}\} que corresponderá a la plantilla \{\{$<$mainPage\}\}.
\end{itemize}
El siguiente código muestra el fichero HTML de la plantilla \{\{layout\}\}:
\begin{lstlisting}[language=HTML]
<template name="layout">
    <div id="main-wrapper">
        {{#if currentUser}}
            {{> sidebar }}
            <div id="page-wrapper">
                {{> header}}
                {{> yield }}
            </div>
       	{{else}}
            {{> yield}}
            {{> loginModal }}
        {{/if}}
    </div>
</template>
\end{lstlisting}
El ayudante (helper) currentUser que proporciona Meteor proporciona una función cuyo valor de retorno es un objeto javascript si el usuario está autenticado o null si no lo está. Por lo que gracias a Spacebars y sus flujos de control (\{\{if\}\},\{\{else\}\}\,{\{/if\}\}) podemos realizar este diseño de forma sencilla.

\subsubsection{Sidebar y header}
\paragraph{}
Uno de los requisitos de la aplicación es que debe ser full-responsive. Esto es que se adapte a cualquier tamaño de pantalla. Por lo que es necesario un diseño adaptativo para cada pantalla de la aplicación en la que el layout no es excepción. Como se muestra en la figura \ref{fig:layoutFR}, la plantilla \{\{$<$sidebar\}\} se ocultará para pantallas estrechas y aparecerá la plantilla \{\{$<$header\}\}. Ésta constará de una serie de botones que al hacer click en cada uno de ellos hará que se se muestre el sidebar con el contenido correspondiente. El diseño del header puede verse siguiente figura: 
\begin{figure}[hb]
	\includegraphics[width=\textwidth]{header}
	\label{fig:header}
	\caption{Diseño header}
\end{figure}

\paragraph{}
El sidebar está compuesta por tres espacios diferenciados (figura \ref{fig:sidMenuV1}):
\begin{itemize}
	\item \textbf{Caja Principal:} en ella aparecerá el logo de la aplicación y el nombre que serán enlaces al recurso raíz (/).
	\item \textbf{Contenido:} el contenido del sidebar se organiza mediante un menú de tabs. 
	\item \textbf{Caja de usuario:} en ella aparecerá el avatar y el nombre de usuario que serán enlaces al recurso perfil y un botón para cerrar sesión.
\end{itemize}
\begin{figure}[htpb]
	\centering
	\includegraphics[height=0.72\textheight]{sidebarMenuVersion1}
	\label{fig:sidMenuV1}
	\caption{Diseño sidebar}
\end{figure}
\subsubsection{Configuración de Iron Router}
\paragraph{}
Iron Router permite establecer una configuración genérica para todas las plantillas especificando la plantilla de carga, el layout, plantilla notFound y subscripciones a las colecciones que necesitemos tener accesibles en todo momento. En este prototipo establecemos solamente la plantilla layout.
\paragraph{}
Puesto que acabamos de hablar del primer recurso de la aplicación debemos establecer una ruta para el mismo especificando qué plantilla ha de mostrarse de la siguiente manera:
\begin{lstlisting}[language=Javascript]
Router.configure({
	layoutTemplate: 'layout'
});

Router.route({'/',
	name: 'mainPage'
});
\end{lstlisting}

\subsection{Registro de usuarios}
\paragraph{}
Para el registro de usuarios creamos una plantilla llamada \{\{>loginModal\}\} que será un Modal de bootstrap y que mediante una variable de sesión de Meteor mostrará un formulario para que los usuarios puedan registrarse u otro para que puedan iniciar sesión. Esta variable de sesión podría ser global y podría ser utilizada para crear un formulario dinámico que dependiera del valor de dicha sesión. Por lo que creamos una plantilla genérica para formularios y después incluimos el que correspondiera según el valor de la variable como sigue:

\begin{lstlisting}[language=HTML]
<template name=loginModal>
	<!-- bootstrap modal-->
		{{>formAwesome}}
	<!-- end bootstrap modal-->
</template>
<template name='formAwesome'>
	{{Template.dynamic template=formTemplate}}
</template>

<template name='signInForm'>
	<button></button>
</template>
<template name='signUpForm'>
	<button></button>
</template>
\end{lstlisting}

\begin{lstlisting}[language=Javascript]
//Cuando el modal se renderiza en el DOM, se establece el valor por defecto
//que es que se muestre el formulario para iniciar sesión.
Template.loginModal.rendered = function(){
	Session.set('formTemplate','signInForm');
};
Template.formAwesome.helpers({
	//El helper template de la plantilla Template.dynamic hace que dicha 
	//plantilla se sustituya por la indicada en dicho helper
	formTemplate: function(){return Session.get('formTemplate')}
});
Template.signInForm.events({
	//cambiamos al formulario de registro.
	'click button': function(){Session.set('formTemplate','signUpForm')}
});

Template.signUpForm.events({
	//cambiamos al formulario de inicio de sesión.
	'click button': function(){Session.set('formTemplate','signInForm')}
});
\end{lstlisting}


\subsubsection{Formulario de inicio de sesión}
Atendiendo a los requisitos los usuarios para iniciar sesión deberán rellenar un formulario con dos campos (figura \ref{fig:signIn}):
\begin{itemize}
	\item \textbf{usuario}: nombre de usuario o email.
	\item \textbf{contraseña}: contraseña del usuario.
\end{itemize}
El inicio de sesión en Meteor se realiza mediante una llamada desde el cliente a la función loginWithPassword proporcionada por el paquete accounts-password pasando como argumento el nombre de usuario o email y la contraseña.
\subsubsection{Formulario de registro}
Atendiendo a los requisitos los usuarios para registrarse deberán suministrar un nombre de usuario, una contraseña y opcionalmente un email (figura \ref{fig:signUp}). El email servirá para la verificación del usuario y para acciones y gestiones que exploraremos más adelante. 
\begin{figure}[htbp]
    \centering
    \subfigure[Formulario de inicio de sesión]{
   	 \includegraphics[scale=0.5]{signInForm.png}
    	\label{fig:signIn}
    }
    \subfigure[Formulario de registro]{
    	\includegraphics[scale=0.45]{signUpForm.png}
	 \label{fig:signUp}
    }
    \caption{Diseño formularios de registro}
    \label{fig:signForms}
\end{figure}
El registro de usuarios en meteor se realiza mediante una llamada en el servidor a la función createUser que proporciona accounts-base. Puesto que el evento asociado al click del botón se encuentra en el cliente se necesita establecer un method en el servidor que sirva de enlace para el cliente. El cliente llamará al method y éste se ejecutará en el servidor llamando a la función createUser. De forma orientativa se muestra el siguiente código:

\begin{lstlisting}[language=Javascript]
if (Meteor.isClient){
	Template.signUpForm.events({
		'click button': function(e){
			var paramsUser; //extraemos los valores de los campos.
			Meteor.call('signUpMethod',paramsUser,function(err,res){
				if (err) throw new Meteor.error('Error al crear el usuario');
				if (res) console.log(usuario creado con id: res);
			});
		}
	});
};

if(Meteor.isServer){
	Meteor.methods({
		'signUpMethod': function(paramsUser){
			if (userIsValid(paramsUser)){
				return Accounts.createUser(paramsUser,callback)
			}else
				return false;
			}
	})
};
\end{lstlisting}

En el momento que el cliente realiza la llamada con los datos suministrados por el usuario, se deberá verificar que los datos son correctos y que cumplen una serie de reglas. (Validación de nuevo usuario). Una vez verificado se creará un objeto usuario en la colección disponible en Meteor.users cuya estructura es la mostrada en la figura \ref{userMongo}. En este momento ya tenemos definida la primera entidad de la aplicación (Usuarios).

El resultado de este prototipo puede verse a continuación:
\begin{figure}[htbp]
    \centering
    \subfigure[Formulario de inicio de sesión]{
   	 \includegraphics[width=0.7\textwidth]{sign-in-form.png}
    	\label{fig:signInReal}
    }
    \subfigure[Formulario de registro]{
    	\includegraphics[width=0.7\textwidth]{sign-up-form.png}
	 \label{fig:signUpReal}
    }
    \caption{Formularios de registro en Página de inicio}
    \label{fig:signFormsReal}
\end{figure}




\section{Prototipo 2: Grabador y reproductor basados en documentos}
\paragraph{}
Este prototipo engloba el diseño y desarrollo del grabador, del reproductor y del recurso en el que se muestran las grabaciones realizadas. 
\subsection{Grabador}
\subsubsection{Entidades y colecciones}
\paragraph{}
En este momento surgen dos nuevas entidades de la aplicación que son las grabaciones y los documentos. La relación que existe entre éstas y los usuarios viene determinada por el diagrama mostrado en la figura (TAL). Dicho diagrama impone que cualquier usuario puede crear una grabación y que ésta debe estar formada por uno o más documentos. Los documentos no existen independientemente de las grabaciones. Como todas las entidades, éstas se traducen en las colecciones Records y Documents cuyos objetos MongoDB se muestran en \ref{recordMongo} y \ref{documentMongo} respectivamente. Al contrario que la colección Users de Meteor, éstas no se crean por defecto. Por lo que, generamos dos nuevos ficheros javascript: app/lib/collections/records.js y app/lib/collections/documents.js. En cada fichero definimos la colección de la siguiente manera:
\begin{lstlisting}[language=Javascript]
	CollectionName = new Mongo.Collection('collectionName');
	//CollectionName será el nombre de la colección accesible en la aplicación.
	//collectionName será el nombre de la colección en MongoDB.
\end{lstlisting}
\subsubsection{Routing}

\paragraph{}
Es necesario crear una nueva ruta para el grabador. Esta ruta será /records/submit y estará accesible en todo momento cumpliendo los requisitos gracias a un nuevo diseño del sidebar que incluye un link a la lista de grabaciones y otro al recurso que acabamos de crear como se muestra en la figura \ref{fig:sidebarV2}.
\paragraph{}
Incluimos una nueva ruta en /app/lib/router.js:
\begin{lstlisting}[language=Javascript]
	Router.route('/records/submit',{
		name: 'recordSubmit'
	});
\end{lstlisting}
\{\{$>$recordSubmit\}\} será la plantilla para nuestro recurso.
\subsubsection{Proceso de grabación}
\begin{figure}[h]
    \centering
    \subfigure[Esquema]{
   	 \includegraphics[width=0.8\textwidth]{recordProcess.png}
    	\label{fig:recordProcessSched}
    }
    \subfigure[Lógica]{
    	\includegraphics[width=0.8\textwidth]{recordProcessObjects.png}
	 \label{fig:recordProcessLogic}
    }
    \caption{Proceso de grabación}
    \label{fig:recordProcess}
\end{figure}
\paragraph{}
Puesto que cada grabación tendrá dos componentes (audio y video) el proceso se realiza de forma diferente para cada una como se muestra en la figura \ref{fig:recordProcessSched} de forma esquemática.
\paragraph{}
Dicho esquema se traduce en la creación de dos objetos javascript: AudioRecorder y EditorManager. Apreciable en la figura \ref{fig:recordProcessLogic}
\begin{itemize}
	\item \textbf{AudioRecorder}: se trata de un constructor que nos permitirá crear un grabador de audio
	\item \textbf{EditorManager}: se trata de un constructor que nos permitirá crear un manejador de documentos, almacenar y actualizarlos de manera dinámica mientras se producen cambios en el editor. 
\end{itemize}
\paragraph{}
La API de RTCRecorder nos proporciona un grabador proporcionándole como parametros un el Stream del usuario y una serie de configuraciones. Para conseguir el Stream utilizamos el módulo navigator del navegador:

\begin{lstlisting}[language=Javascript]
	navigator.getUserMedia  = navigator.getUserMedia || 
						 navigator.webkitGetUserMedia || 
						 navigator.mozGetUserMedia || 
						 navigator.msGetUserMedia;
	var audioConstraints = {audio: true, video: false};
	navigator.getUserMedia(audioConstraints,function(stream){
		var settings = {}
		var recorder = window.RecordRTC(stream,settings);
		recorder.startRecording();
	},function(error){
		throw new Meteor.error(error.reason);
	});
\end{lstlisting}
El código anterior se encuentra dentro de un método (startRecording) del constructor AudioRecorder y la variable recorder se encuentra accesible por todos los métodos del mismo por lo que tenemos accesible el grabador proporcionado por RTCRecorder. 
\paragraph{}El proceso de grabación sobre el editor se basa en generar una lista de acciones indexadas por marcas de tiempo. Dichas marcas de tiempo corresponderán al instante en el que se produce un cambio en el editor y dicho cambio se traducirá en una acción (método proporcionado por la API de AceEditor) para que en ese instante durante el proceso de reproducción se ejecute dicha acción simulando el cambio que se haya producido durante la grabación.
\paragraph{}
Para lo anterior es necesario capturar los cambios del editor, a través de la API de AceEditor, y extraer el instante correspondiente. En el momento que comienza la grabación se ejecuta un callback pasado por parámetro que sirve para arrancar el reloj de la grabación. Dicho reloj será accesible dentro de la plantilla \{\{$>$recordSubmit\}\}. Por lo que la sincronización con los cambios en el editor será perfecta.
\paragraph{}
El siguiente código sirve de ejemplo para ilustrar la captura de eventos: 
\begin{lstlisting}[language=Javascript]
var editor = ace.editor('#id');
editor.getSession().on('change', function(e) {
     switch (e.action) {
     	case "remove":
         	var rmRange = {start: e.start, end: e.end};
          docsManagerRecorder.insertFunctions([{
                time: new Date() - date,
                arg: rmRange,
                toDo: 'editor.getSession().getDocument().remove(arg);'
           }]);
           break;
       }
});
\end{lstlisting}
\paragraph{}
Como puede verse en el código anterior docsManagerRecorder es nuestro objeto construido mediante EditorManager y mediante su método insertFunctions generamos nuevas acciones que se simularán durante la reproducción en el instante almacenado en su atributo time.

\paragraph{}
Puesto que una grabación debe estar formada por uno o más documentos, durante la grabación puede producirse la creación de nuevos documentos y del cambio de uno a otro sobre el editor. Estos cambios deben ser visibles durante la reproducción por lo tanto deben ser capturados. La captura se realiza mediante los eventos que se produzcan en la plantilla correspondiente al crearse un nuevo documento o visualizar otro distinto al actual. En el momento que alguno de estos eventos se produzca se generará una nueva acción que insertar en la lista de acciones mediante el método insertFunctions. 
\paragraph{}
Los eventos posibles que se traducen en acciones son los siguientes: 
\begin{itemize}
	\item Borrar: se borra contenido.
	\item Insertar: se inserta contenido.
	\item Selección: cambia la selección del cursor.
	\item Cursor: cambia la posición del cursor.
	\item Scroll: cambia la altura del scroll.
	\item Creación documento: el usuario crea un nuevo documento.
	\item Cambio de documento: el usuario selecciona otro documento distinto al actual para su visualización.
\end{itemize}

\subsubsection{Almacenamiento}
Como podemos observar en la figura \ref{fig:recordProcess}, una vez termina la grabación se deben proporcionar herramientas para su almacenamiento persistente. El almacenamiento de dicha grabación se realizará por separado según sus componentes. Un objeto record compuesto por información sobre la grabación y la lista de acciones (\ref{recordMongo}) se almacenará en la colección Records de MongoDB y el archivo de audio en SoundCloud. 
\paragraph{}
Para utilizar la API de SoundCloud es necesaria la instalación de un nuevo paquete: monbro:soundcloud-nodejs-api-wrapper  . Este paquete es un wrapper (envoltorio) del SDK (Software Development Kit) de SoundCloud que permite realizar llamadas REST a la API desde el lado del servidor gracias al objeto SoundCloud que nos proporciona de manera global. 
\paragraph{}
Para inicializar dicho objeto necesitaremos un usuario en SoundCloud y crear una aplicación en su espacio para desarrolladores. Dicha aplicación nos proporcionará una serie de credenciales que nos permitirán comunicarnos con la API: identificador de la aplicación, clave secreta de la aplicación. Al crearla necesitaremos proporcionarle una url de redirección para la autenticación mediante el protocolo OAuth. 
\paragraph{}
Usando solamente el SDK en el cliente, a la hora de conectar con la API, comenzaría un proceso de autenticación que mostraría un popup que exige interacción con el usuario. Dicho proceso no es transparente al usuario y eso es algo que hemos querido arreglar. La solución es incorporar como parámetro de incialización del SDK un token OAuth (el devuelto tras el proceso de autenticación). El problema está en que dicho token tiene una fecha de expiración y el SDK para Javascript no proporciona herramientas para refrescar el token ya que no tiene método para realizar esa petición REST en cuestión. Pero el paquete mencionado anteriormente sí tiene esa funcionalidad, y es que cada vez que llamamos a su método .getClient(), nos devuelve un cliente con un token completamente nuevo. 
\paragraph{}
Por este motivo creamos el fichero /app/server/soundcloud.js en el que inicializar el objeto SoundCloud y crear el method .getClientSC al que podemos llamar desde el cliente y que nos devuelve los parámetros necesarios para incializar el SDK del cliente de forma que se conecte a la API de SoundCloud de forma transparente al usuario.
\paragraph{}
El siguiente código ilustra este proceso: 
\begin{lstlisting}[language=Javascript]
if (Meteor.isServer()){
	Soudcloud.setConfig({
		client_id: CLIENT_ID,
		client_secret: CLIENT_SECRET,
		username: USERNAME,
		password: PASSWORD
	});
	
	Meteor.methods({
		getClientSC: function(){
			var client = Soundcloud.getClient();
			return {
				client_id: CLIENT_ID,
				access_token: client.settings.access_token
			}
		}
	});
}
if (Meteor.isClient()){
	$.getScript("https://cdn.WebRTC-Experiment.com/RecordRTC.js",function(){
		Meteor.call('getClientSC',function(err,res){
			if (err) throw new Meteor.error(err.reason);
			if (res){
				SC.initialize({
					client_id: res.client_id,
					oauth_token: res.access_token,
					scope: 'non-expiring'
				});
			}
		});
	});
}
\end{lstlisting}

\paragraph{}
Las variables CLIENT\_ID Y CLIENT\_SECRET contienen el id de la aplicación que hemos creado en Soundcloud y su clave secreta respectivamente.
\paragraph{}
Una vez que tenemos inicializado el SDK en el cliente podemos realizar la subida del audio de la siguiente manera: 
\begin{lstlisting}[language=Javascript]
var recordMongoObject = {};
SC.connect().then(function(){
	SC.upload({
		file: recorder.getAudio(), //Blob
		title: 'title'
	}).then(function(track){
		recordMongoObject.track = {
			id: track.id,
			link: track.uri
		}
		//llamada al servidor para almacenar el objeto.
	})
})
\end{lstlisting}
\paragraph{} 
En el código anterior se muestra cómo se crea una referencia al archivo subido mediante su identificador. Una vez tenemos el objeto completado realizamos la llamada al method insertRecord, creado en el archivo /app/lib/collections/records.js para almacenar la grabación en MongoDB.


\subsubsection{Interfaz del grabador}
La interfaz del grabador está formado por dos espacios: la pantalla en la que se mostrará una plantilla u otra dependiendo de las acciones a realizar y una caja con botones que determinarán dichas acciones. Además, como se graban documentos sobre editor, constará de una pestaña en la que aparecerá el título del documento que está siendo editado y un botón para acceder a la lista de documentos como se muestra en la figura \ref{fig:recorderBase}

\paragraph{}
El diseño del grabador se compone de las siguientes plantillas: 
\begin{itemize}
	\item \textbf{\{\{$<$initial\}\}}: es la que se muestra inicialmente y consta de un botón para mostrar la lista de documentos.
	\item \textbf{\{\{$<$documentList\}\}}: se muestra como un panel dentro de la pantalla de la interfaz y contiene un botón para mostrar el formulario de creación de documentos y la lista de documentos creados. Al hacer click en cada uno de ellos lo visualizaremos en la pantalla. Cada miniatura de los documentos posee un enlace de edición que muestra el formulario de creación con los datos del propio documento.
	\item \textbf{\{\{$<$documentForm\}\}}: es el formulario de edición y creación de los documentos. Se deberá introducir un título, un lenguaje de programación y un tema para el editor (estos dos últimos son opcionales).
	\item \textbf{\{\{$<$editor\}\}}: plantilla en la que se muestra el editor con el contenido de los documentos.
	\item \textbf{\{\{$<$actions\}\}}: esta plantilla está presente a lo largo de todo el proceso de grabación y determina las acciones a realizar según el estado del mismo (grabar, parar, guardar/cancelar).
	\item \textbf{\{\{$<$final\}\}}: al finalizar la grabación se muestra en la pantalla de la interfaz un mensaje.
	\item \textbf{\{\{$<$saveForm\}\}}: es el formulario para guardar nuestra grabación. Se deberá introducir un título y opcionalmente una descripción y una lista de etiquetas mediante un auto-completado de etiquetas que se ha elaborado.
	\item \textbf{\{\{$<$upload\}\}}:  al hacer click en guardar en la plantilla anterior se mostrará el progreso de subida del audio y cuando termine un mensaje y un enlace a la página de la grabación (reproductor) para reproducir la grabación.
\end{itemize}
\paragraph{}
Tras este análisis hemos encontrado una nueva entidad: etiquetas (Tags) por lo que creamos una nueva colección y un nuevo fichero en /app/lib/collections de forma análoga con las anteriores. Establecemos que una grabación puede tener o no etiquetas y que son globales es decir que la misma etiqueta la pueden tener una o varias grabaciones. Esta relación puede verse en el diagrama (tal).
\paragraph{}
El flujo de plantillas se muestra en la figura \ref{fig:grabacionFlujo}
Las plantillas presentes en la figura anterior corresponden a las figuras: \ref{fig:recorderNoDocs}, \ref{fig:recorderDocsList}, \ref{fig:documentForm}, \ref{fig:recorderEditor}, \ref{fig:recorderFinal} y \ref{fig:uploadProcess} disponibles en el apéndice \ref{appendix:mockupsApendix}.
\paragraph{}
Una vez desarrollado el grabador este es el resultado:
\begin{figure}[h]
	\centering
	\includegraphics[width=0.75\textwidth]{recorder.png}
	\caption{Grabador}
	\label{fig:recorder}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{recorderFlow.png}
	\label{fig:grabacionFlujo}
	\caption{Flujo de plantillas del grabador}
\end{figure}
\subsection{Reproductor}
\subsection{Lista de grabaciones}

\section{Prototipo 3: Respuestas a grabaciones}
\section{Prototipo 4: Página de perfil}
\section{Prototipo 5: Formularios dinámicos y complementos}
\section{Prototipo 6: Organización en Canales}
\section{Prototipo 7: Organización en Lecciones}
\section{Prototipo 8: Contactos}
\section{Prototipo 9: Conversaciones}
\section{Prototipo 10: Emails e integración de servicios de registro}
\section{Prototipo 11: Página principal}
\section{Prototipo 12: Página de inicio, espacio para tutoriales y features}
\section{Prototipo Final: Restricciones de acceso y cross-browsing}
\section{Despliegue y pruebas globales}
