\chapter{Diseño y desarrollo de la aplicación}
En este capítulo se describe detalladamente el proceso de diseño e implementación de la aplicación. Las tres primeras secciones están a modo de introducción y describen el tipo de arquitectura de software escogida, el proceso de búsqueda de herramientas de desarrollo, la composición inicial y el entorno y, por último, la tecnología utilizada para el despliegue. En las secciones sucesivas se detalla el diseño y desarrollo de los prototipos más relevantes de los que se compone esta aplicación. La descripción de los prototipos menos relevantes se encuentra en el apéndice \ref{appendix:prototipos}. En cada prototipo se muestran los diseños de las interfaces correspondientes a la fase de diseño del mismo.
\section{Arquitectura de Software utilizada}
\paragraph{}
El modelo de arquitectura más habitual es el \textbf{MVC} (Modelo Vista Controlador) (figura \ref{fig:mvcpattern}). El modelo correspondería con la arquitectura de base de datos y el diseño de la misma, la vista son las interfaces o plantillas que se muestran al usuario y el controlador es el encargado de dotar a la aplicación de lógica y funcionalidad. Existen otros tipos de arquitectura tales como \textbf{MVVM} (figura \ref{fig:mvvmpattern}), donde el controlador del patrón MVC se sustituye por VM o \emph{ViewModel} que establece que cada vista posee lógica y un sistema de \emph{data-binding} entre plantillas.

\begin{figure}[htbp]
    \centering
    \subfigure[Patrón de arquitectura MVC]{
   	 \includegraphics[width=.8\textwidth]{mvc.png}
    	\label{fig:mvcpattern}
    }
    \subfigure[Patrón de arquitectura MVVM]{
    	\includegraphics[width=.8\textwidth]{mvvm.png}
	 \label{fig:mvvmpattern}
    }
    \caption{Patrones de arquitectura}
    \label{fig:patterns}
\end{figure}

\paragraph{}
La elección del patrón de arquitectura a usar es importante puesto que esa decisión nos limitará a la hora de usar determinadas herramientas. El patrón MVVM está presente en cada uno de los frameworks con data-binding que se conocen (Angular, Meteor, etc). Debido a que este data-binding va a ser útil para cumplir con el objetivo de que la aplicación debe funcionar en tiempo real y poseer un renderizado rápido y óptimo, el patrón a usar para esta aplicación será el MVVM.
\paragraph{}

\section{Búsqueda de herramientas}
\paragraph{}
Partiendo de los requisitos establecidos que caracterizarán la aplicación podemos afirmar que necesitamos encontrar herramientas que nos permitan construir una aplicación en \emph{tiempo real}, realizar \emph{grabaciones de audio}, una interfaz con \textbf{UX} (User eXperience) como parámetro fundamental y que trabaje de manera óptima.

\subsubsection{Aplicación en tiempo real y prototipado rápido}
\paragraph{}
Necesitamos algún framework o plataforma que trabaje con el concepto de reactividad o que lo simule. Elegimos MeteorJS por su flexibilidad, su asombroso concepto de reactividad y por su patrón de trabajo que engloba el desarrollo del cliente y del servidor. Debido a esta elección utilizaremos MongoDB como tecnología de base de datos y MVVM como patrón de arquitectura de la aplicación.
\paragraph{}
Para el \textbf{enrutamiento} es precisa otra herramienta que nos proporcione la funcionalidad de especificar a qué recurso pertenece una plantilla y que datos asociamos a ella. Para ello se ha optado por el paquete para Meteor \textbf{IronRouter}.
\paragraph{}
Para el concepto de \textbf{publicaciones} y \textbf{subscripciones} de Meteor usaremos \textbf{publishComposite}, un paquete que permite realizar \emph{publicaciones compuestas} (varias colecciones con relación de dependencia reactiva) y que siguen manteniendo el principio de reactividad y optimizando nuestro sistema de \emph{subscripciones}. Sin este paquete realizar esta labor es más compleja. 

\subsubsection{Grabaciones de audio}
\paragraph{}
Existen numerosas formas de grabar audio vía web y algunas API de sitios como SoundCloud incorporan un grabador de audio directamente. Aunque esta hubiera sido la vía más rápida, la verdad es que no habría sido la más flexible, ya que el hacerlo de esta manera requería que el uploading se efectuara en SoundCloud. Por este motivo se ha utilizado la tecnología de WebRTC para esta tarea y construido un grabador modular que puede incorporarse fácilmente a otros proyectos y que además si se desea usar el servicio de hosting de SoundCloud seguiría siendo factible. 

\subsubsection{Hosting o Almacenamiento}
\paragraph{}
Utilizaremos el servicio de hosting de SoundCloud para almacenar el audio de nuestras grabaciones. No es lo más sensato para una aplicación real y comercializable puesto que existen restricciones en lo referente a capacidad, pero para nuestra aplicación es más que suficiente. 

\subsubsection{Interfaz con UX como parámetro de diseño fundamental}
\paragraph{}
Partiendo del requisito de que la aplicación debe ser atractiva al usuario y no sólo en términos visuales sino en \emph{eficacia} a la hora de gestionar acciones, en este proyecto nos hemos decantado por el framework front-end \textbf{Bootstrap} para la maquetación y por la tecnología \textbf{Flexbox} para dotar de flexibilidad a las plantillas. Además utilizaremos \textbf{SASS} como preprocesador de CSS con el fin de optimizar nuestra arquitectura de estilos mediante un paquete para Meteor. Además para el diseño de cada una de las interfaces de la aplicación se ha utilizado un software de diseño de mockups llamado \textbf{Balsamiq}\footnote{\url{https://balsamiq.com/}}. La mayoría de los diseños pueden verse en el apéndice \ref{appendix:mockupsApendix}.


\section{Composición Inicial y entorno de desarrollo}
\paragraph{}
Una vez realizada la búsqueda de herramientas comenzamos a componer el entorno de nuestra aplicación. Para este proyecto utilizaremos el programa \textbf{WebStorm}\footnote{\url{https://www.jetbrains.com/webstorm/}} de \emph{JetBrains}. Incorpora herramientas de búsqueda y sustitución avanzada, terminal para comandos, integración con sistema de control de versiones Git y plugins que facilitan la labor de desarrollo como \textbf{emmet}\footnote{\url{https://www.jetbrains.com/help/webstorm/2016.1/emmet.html}}.
\subsection{Creación de la aplicación y paquetes iniciales}
\paragraph{}
Gracias al CLI de Meteor generamos nuestra aplicación mediante el comando: \emph{meteor create $<$AppName$>$}. Esto nos genera una carpeta con tres ficheros: index.html, index.js e index.css. En este momento ya tenemos nuestra aplicación Meteor creada. 
\paragraph{}
Ahora debemos estructurar nuestra aplicación según la jerarquía mostrada en la figura \ref{fig:hierarchyFolders} creando los ficheros y carpetas necesarios.

\paragraph{}
Una vez estructurada la aplicación instalamos los paquetes iniciales mediante el comando: \emph{meteor add $<$PackageName$>$}. La lista de paquetes iniciales es la siguiente: 
\begin{itemize}
\item \textbf{accounts-base:} paquete base para cuentas de usuario.
\item \textbf{accounts-password:} contraseña como servicio de registro de usuarios.
\item \textbf{fortawesome:fontawesome:} biblioteca de iconos.
\item \textbf{fourseven:scss:} preprocesador Sass para estilos.
\item \textbf{iron:router:} paquete para enrutamiento.
\item \textbf{mizzao:bootstrap-3} maquetación.
\item \textbf{reywood:publish-composite:} publicaciones avanzadas y compuestas.
\end{itemize}

\subsection{Mixins}
\paragraph{}
SASS nos permite crear reglas dinámicas de estilos que poder incluir en cualquier clase llamados mixins. Para este proyecto hemos utilizado este concepto para la labor de cross-browsing. Esta labor se basa en la traducción de una misma regla a los distintos navegadores Web, ya que cada navegador interpreta algunas reglas de forma distinta. Por lo que estos mixins nos permiten unificar diferentes reglas que se interpretan de manera distinta dependiendo del navegador. Un ejemplo de mixin es el siguiente: 
\begin{lstlisting}[caption=Mixin border-radius, label={mixinEj}]
@mixin border-radius($radius){
	-webkit-border-radius: $radius;  #safari, chrome
	-moz-border-radius: $radius; #mozilla firefox
	-ms-border-radius: $radius; #Internet Explorer
	border-radius: $radius; #new
}
\end{lstlisting}
\paragraph{}
Creamos un fichero con el nombre de \_mixins.scss dentro de la carpeta client al nivel del fichero index.html. El carácter \_ indica al preprocesador que esta hoja de estilos no la debe procesar. El procesado lo realizará en el momento que la importemos a otra hoja de estilos e incluyamos algún mixin.
Los mixins más utilizados en este proyecto serán los siguientes: border-radius, flexbox (flex, flex-direction, flex-wrap, etc), opacity, transition, animation y gradient. El archivo está disponible en el repositorio de GitHub\cite{bazGitRepo}.
\section{Despliegue}
El despliegue se ha llevado a cabo mediante el sistema de Hosting de Heroku \cite{bazHeroku}, basado en un respositorio remoto de GitHub y un paquete constructor que genera la aplicación a partir del estado de ese repositorio. 

\subsection{Proceso}
Para realizar este despliegue ha sido necesario crear una cuenta en heroku y descargar el CLI para poder desplegar nuestra aplicación de forma remota. El despliegue en Heroku se basa en una idea muy simple. El despliegue es tan sencillo como almacenar una nueva versión de tu repositorio local en el repositorio remoto en github. Una vez autenticado mediante el comando del CLI heroku login, creamos una aplicación a la que damos el nombre de duckflight. Acto seguido nos devuelve dos urls que corresponden a dos repositorios remotos de github. Esa url la añadiremos como repositorio remoto al actual.
\paragraph{}
Ahora necesitamos una base de datos remota, ya que hasta ahora habíamos trabajado con la base de datos que nos creaba Meteor. Para ello creamos un sandbox en \textbf{mlab} mediante el CLI de heroku. Esto nos devolverá la url de la base de datos que deberemos atribuir como parámetro global a la aplicación duckflight. 
\paragraph{}
Finalmente necesitamos un paquete constructor que se encargue de identificar que se trata de una aplicación de Meteor y de generarla en la url en la que se hará el despliegue. Dicho paquete es \textbf{jordansissel:heroku-buildpack-meteor} y se configura mediante el comando \emph{heroku create --buildpack <buildpack>}. 
\paragraph{}
Una vez seguidos estos pasos, procedemos al despliegue de la aplicación mediante el comando \emph{git push heroku master}.
\paragraph{}
En el momento que ejecutamos el comando anterior se crea una copia de nuestro repositorio local en el repositorio remoto heroku. Acto seguido el \textbf{buildpack} o paquete constructor se encarga de generar nuestra aplicación y de arrancarla en la url correspondiente.

\subsection{Licencias}
Un requisito indispensable a la hora de realizar el despliegue de manera pública es el de incluir licencias al código que preserven los derechos de autor y conviertan el código, en este caso, en código libre o abierto. 
\paragraph{}
Para el código fuente se ha utilizado la licencia libre y gratuita de \textbf{GNU APGL}\footnote{\url{https://www.gnu.org/licenses/why-affero-gpl.html}} creando un fichero /app/license.txt que contiene las bases e integrando referencias a dicha licencia en cada uno de los ficheros de código fuente de la aplicación. 
\paragraph{}
Para el producto visible se ha utilizado una licencia \textbf{Creative Commons}\footnote{\url{http://es.creativecommons.org/blog/licencias/}} que deniega cualquier uso comercial de la aplicación y derivados. Se ha incluido en el sitio mediante una etiqueta en documento HTML de la página de inicio.
\section{Prototipo 1: Registro de usuarios y layout principal}
\paragraph{}
Este es el primer prototipo de la aplicación y se corresponde con el layout principal de la aplicación y con el registro de usuarios. La extracción de requisitos se corresponde con los enumerados en \ref{rReg}.
\subsection{Layout principal}
\begin{figure}[htbp]
    \centering
    \subfigure[Large layout]{
   	 \includegraphics[scale=0.42]{layoutLarge.png}
    	\label{fig:layoutLg}
    }
    \subfigure[Small Layout]{
    	\includegraphics[scale=0.42]{layoutSmall.png}
	 \label{fig:layoutSm}
    }
    \caption{Diseño de Layout Full-responsive}
    \label{fig:layoutFR}
\end{figure}
Iron Router establece que el diseño de la aplicación debe realizarse en torno a dos plantillas: \{\{yield\}\} y \{\{layout\}\}. El layout es la plantilla genérica y el yield es el contenido. Como puede verse en la figura \ref{fig:layoutFR}, ésta va a ser la estructura genérica de nuestra aplicación: 
\begin{itemize}
	\item \textbf{Layout: } estará compuesta por un sidebar, un header y la plantilla yield.
	\item \textbf{Yield:} esta plantilla es dinámica y se podrá asignar una plantilla u otra dependiendo de la ruta en la que nos encontremos.
\end{itemize}
\paragraph{}
Partiendo del requisito de que los usuarios deben estar autenticados para acceder a la funcionalidad de la aplicación es necesario diseñar el flujo de registro de usuario y situarlo en un recurso o ruta. Debido a esta restricción el flujo se situará en el recurso raíz (/). Por lo que, dependiendo de si el usuario está autenticado o no al acceder a esta ruta deberá mostrarse una plantilla u otra. En este caso:
\begin{itemize}
\item Si el usuario está autenticado el layout estará compuesto por la plantilla \{\{$>$sidebar\}\},  \{\{$>$header\}\} y la plantilla \{\{$>$yield\}\} que corresponderá a la plantilla \{\{$>$startPage\}\}.
\item  Si el usuario no está autenticado el layout estará compuesto solamente por la plantilla \{\{$>$yield\}\} que corresponderá a la plantilla \{\{$>$mainPage\}\}.
\end{itemize}
El siguiente código muestra el fichero HTML de la plantilla \{\{layout\}\}:
\vspace{0.5cm}
\begin{lstlisting}[language=HTML]
<template name="layout">
    <div id="main-wrapper">
        {{#if currentUser}}
            {{> sidebar }}
            <div id="page-wrapper">
                {{> header}}
                {{> yield }}
            </div>
       	{{else}}
            {{> yield}}
            {{> loginModal }}
        {{/if}}
    </div>
</template>
\end{lstlisting}
\vspace{0.5cm}
El ayudante (helper) currentUser que proporciona Meteor proporciona una función cuyo valor de retorno es un objeto javascript si el usuario está autenticado o null si no lo está. Por lo que gracias a Spacebars y sus flujos de control (\{\{if\}\},\{\{else\}\}\,{\{/if\}\}) podemos realizar este diseño de forma sencilla.

\subsubsection{Sidebar y header}
\paragraph{}
Uno de los requisitos de la aplicación es que debe ser full-responsive. Esto es que se adapte a cualquier tamaño de pantalla. Por lo que es necesario un diseño adaptativo para cada pantalla de la aplicación en la que el layout no es excepción. Como se muestra en la figura \ref{fig:layoutFR}, la plantilla \{\{$>$sidebar\}\} se ocultará para pantallas estrechas y aparecerá la plantilla \{\{$>$header\}\}. Ésta constará de una serie de botones que al hacer click en cada uno de ellos hará que se se muestre el sidebar con el contenido correspondiente. El diseño del header puede verse siguiente figura: 
\begin{figure}[hb]
	\centering
	\includegraphics[width=0.8\textwidth]{header}
	\label{fig:header}
	\caption{Diseño header}
\end{figure}

\paragraph{}
El sidebar está compuesta por tres espacios diferenciados como pueede apreciarse en sidebarV1 de la figura \ref{fig:sidebarVersions}:
\begin{itemize}
	\item \textbf{Caja Principal:} en ella aparecerá el logo de la aplicación y el nombre que serán enlaces al recurso raíz (/).
	\item \textbf{Contenido:} el contenido del sidebar se organiza mediante un menú de tabs. 
	\item \textbf{Caja de usuario:} en ella aparecerá el avatar y el nombre de usuario que serán enlaces al recurso perfil y un botón para cerrar sesión.
\end{itemize}
\subsubsection{Configuración de Iron Router}
\paragraph{}
Iron Router permite establecer una configuración genérica para todas las plantillas especificando la plantilla de carga, el layout, plantilla notFound y subscripciones a las colecciones que necesitemos tener accesibles en todo momento. En este prototipo establecemos solamente la plantilla layout.
\paragraph{}
Puesto que acabamos de hablar del primer recurso de la aplicación debemos establecer una ruta para el mismo especificando qué plantilla ha de mostrarse de la siguiente manera:
\vspace{0.5cm}
\begin{lstlisting}[language=Javascript]
Router.configure({
	layoutTemplate: 'layout'
});

Router.route({'/',
	name: 'mainPage'
});
\end{lstlisting}
\vspace{0.5cm}
\subsection{Registro de usuarios}
\paragraph{}
Para el registro de usuarios creamos una plantilla llamada \{\{$>$loginModal\}\} que será un Modal de bootstrap y que mediante una variable de sesión de Meteor mostrará un formulario para que los usuarios puedan registrarse u otro para que puedan iniciar sesión. Esta variable de sesión podría ser global y podría ser utilizada para crear un formulario dinámico que dependiera del valor de dicha sesión. Por lo que creamos una plantilla genérica para formularios y después incluimos el que correspondiera según el valor de la variable como sigue:
\vspace{0.5cm}
\begin{lstlisting}[language=HTML]
<template name=loginModal>
	<!-- bootstrap modal-->
		{{>formAwesome}}
	<!-- end bootstrap modal-->
</template>
<template name='formAwesome'>
	{{Template.dynamic template=formTemplate}}
</template>

<template name='signInForm'>
	<button></button>
</template>
<template name='signUpForm'>
	<button></button>
</template>
\end{lstlisting}
\vspace{0.5cm}
\begin{lstlisting}[language=Javascript]
//Cuando el modal se renderiza en el DOM, se establece el valor por defecto
//que es que se muestre el formulario para iniciar sesión.
Template.loginModal.rendered = function(){
	Session.set('formTemplate','signInForm');
};
Template.formAwesome.helpers({
	//El helper template de la plantilla Template.dynamic hace que dicha 
	//plantilla se sustituya por la indicada en dicho helper
	formTemplate: function(){return Session.get('formTemplate')}
});
Template.signInForm.events({
	//cambiamos al formulario de registro.
	'click button': function(){Session.set('formTemplate','signUpForm')}
});

Template.signUpForm.events({
	//cambiamos al formulario de inicio de sesión.
	'click button': function(){Session.set('formTemplate','signInForm')}
});
\end{lstlisting}
\vspace{0.5cm}

\subsubsection{Formulario de inicio de sesión}
Atendiendo a los requisitos los usuarios para iniciar sesión deberán rellenar un formulario con dos campos (figura \ref{fig:signIn}):
\begin{itemize}
	\item \textbf{usuario}: nombre de usuario o email.
	\item \textbf{contraseña}: contraseña del usuario.
\end{itemize}
El inicio de sesión en Meteor se realiza mediante una llamada desde el cliente a la función \emph{.loginWithPassword} proporcionada por el paquete \textbf{accounts-password} pasando como argumento el nombre de usuario o email y la contraseña.
\subsubsection{Formulario de registro}
Atendiendo a los requisitos los usuarios para registrarse deberán suministrar un nombre de usuario, una contraseña y opcionalmente un email (figura \ref{fig:signUp}). El email servirá para la verificación del usuario y para acciones y gestiones que exploraremos más adelante. 

\begin{figure}[htbp]
    \centering
    \subfigure[Formulario de inicio de sesión]{
   	 \includegraphics[scale=0.5]{signInForm.png}
    	\label{fig:signIn}
    }
    \subfigure[Formulario de registro]{
    	\includegraphics[scale=0.45]{signUpForm.png}
	 \label{fig:signUp}
    }
    \caption{Diseño formularios de registro}
    \label{fig:signForms}
\end{figure}
El registro de usuarios en meteor se realiza mediante una llamada en el servidor a la función \emph{.createUser} que proporciona \textbf{accounts-base}. Puesto que el evento asociado al click del botón se encuentra en el cliente se necesita establecer un \emph{method} en el servidor que sirva de enlace para el cliente. El cliente llamará al method y éste se ejecutará en el servidor llamando a la función createUser. De forma orientativa se muestra el siguiente código:
\vspace{0.5cm}
\begin{lstlisting}[language=Javascript]
if (Meteor.isClient){
	Template.signUpForm.events({
		'click button': function(e){
			var paramsUser; //extraemos los valores de los campos.
			Meteor.call('signUpMethod',paramsUser,function(err,res){					if (res) console.log(usuario creado con id: res);
			});
		}
	});
};

if(Meteor.isServer){
	Meteor.methods({
		'signUpMethod': function(paramsUser){
			if (userIsValid(paramsUser)){
				return Accounts.createUser(paramsUser,callback)
			}
			return false;
	})
};
\end{lstlisting}
\vspace{0.5cm}
En el momento que el cliente realiza la llamada con los datos suministrados por el usuario, se deberá verificar que los datos son correctos y que cumplen una serie de reglas. (Validación de nuevo usuario). Una vez verificado se creará un objeto usuario en la colección disponible en Meteor.users cuya estructura es la mostrada en la figura \ref{userMongo}. En este momento ya tenemos definida la primera entidad de la aplicación: Usuarios. Su relación con otras futuras entidades se muestra en la figura \ref{fig:ERdesign}.
\begin{figure}[htpb]
	\centering
	\includegraphics[width=0.9\textwidth]{ERdesign.png}
	\caption{Esquema entidad relación}
	\label{fig:ERdesign}
\end{figure}

El resultado de este prototipo puede verse en las capturas de pantalla de la figura \ref{fig:signFormsReal}

\section{Prototipo 2: Grabador y reproductor basados en documentos}
\paragraph{}
Este prototipo engloba el diseño y desarrollo del grabador, del reproductor y del recurso en el que se muestran las grabaciones realizadas. Los requisitos extraídos en este prototipo son los mostrados en \ref{rRec}.
\subsection{Grabador}
\subsubsection{Entidades y colecciones}
\paragraph{}
En este momento surgen dos nuevas entidades de la aplicación que son las \textbf{grabaciones} y los \textbf{documentos}. La relación que existe entre éstas y los usuarios viene determinada por el diagrama mostrado en la figura \ref{fig:ERdesign}. Dicho diagrama impone que cualquier usuario puede crear una grabación y que ésta debe estar formada por uno o más documentos. Los documentos no existen independientemente de las grabaciones. Como todas las entidades, éstas se traducen en las colecciones \textbf{Recordings} y \textbf{Documents} cuyos objetos MongoDB se muestran en \ref{recordMongo} y \ref{documentMongo} respectivamente. Al contrario que la colección Users de Meteor, éstas no se crean por defecto. Por lo que, generamos dos nuevos ficheros javascript: \emph{app/lib/collections/records.js} y \emph{app/lib/collections/documents.js}. En cada fichero definimos la colección de la siguiente manera:
\begin{lstlisting}[language=Javascript]
	CollectionName = new Mongo.Collection('collectionName');
	//CollectionName será el nombre de la colección accesible en la aplicación.
	//collectionName será el nombre de la colección en MongoDB.
\end{lstlisting}
\subsubsection{Routing}

\paragraph{}
Es necesario crear una nueva ruta para el grabador. Esta ruta será \emph{/records/submit} y estará accesible en todo momento cumpliendo los requisitos gracias a un nuevo diseño del sidebar que incluye un link a la lista de grabaciones y otro al recurso que acabamos de crear como se muestra en la figura \ref{fig:sidebarVersions}.
\paragraph{}
Incluimos una nueva ruta en \emph{/app/lib/router.js}:
\begin{lstlisting}[language=Javascript]
	Router.route('/records/submit',{
		name: 'recordSubmit'
	});
\end{lstlisting}
\{\{$>$recordSubmit\}\} será la plantilla para nuestro recurso.
\subsubsection{Proceso de grabación}
\begin{figure}[h]
    \centering
    \subfigure[Esquema]{
   	 \includegraphics[width=0.8\textwidth]{recordProcess.png}
    	\label{fig:recordProcessSched}
    }
    \subfigure[Lógica]{
    	\includegraphics[width=0.8\textwidth]{recordProcessObjects.png}
	 \label{fig:recordProcessLogic}
    }
    \caption{Proceso de grabación}
    \label{fig:recordProcess}
\end{figure}
\paragraph{}
Puesto que cada grabación tendrá dos componentes (audio y video) el proceso se realiza de forma diferente para cada una como se muestra en la figura \ref{fig:recordProcessSched} de forma esquemática.
\paragraph{}
Dicho esquema se traduce en la creación de dos objetos javascript: \textbf{AudioRecorder} y \textbf{EditorManager}. Apreciable en la figura \ref{fig:recordProcessLogic}
\begin{itemize}
	\item \textbf{AudioRecorder}: se trata de un constructor que nos permitirá crear un grabador de audio
	\item \textbf{EditorManager}: se trata de un constructor que nos permitirá crear un manejador de documentos, almacenar y actualizarlos de manera dinámica mientras se producen cambios en el editor. 
\end{itemize}
\paragraph{}
La API de \textbf{RTCRecorder} nos proporciona un grabador proporcionándole como parámetros un el Stream del usuario y una serie de configuraciones. Para conseguir el Stream utilizamos el módulo \textbf{navigator} del navegador (código de ejemplo \ref{code:navigator})

\paragraph{}
El código anterior se encuentra dentro de un método (startRecording) del constructor AudioRecorder y la variable recorder se encuentra accesible por todos los métodos del mismo por lo que tenemos accesible el grabador proporcionado por RTCRecorder. 
\paragraph{}El proceso de grabación sobre el editor se basa en generar una lista de \emph{acciones indexadas por marcas de tiempo}. Dichas marcas de tiempo corresponderán al instante en el que se produce un cambio en el editor y dicho cambio se traducirá en una acción (método proporcionado por la API de \textbf{AceEditor}) para que en ese instante durante el proceso de reproducción se ejecute dicha acción simulando el cambio que se haya producido durante la grabación.
\paragraph{}
Para lo anterior es necesario capturar los cambios del editor, a través de la API de AceEditor, y extraer el instante correspondiente. En el momento que comienza la grabación se ejecuta un callback pasado por parámetro que sirve para arrancar el reloj de la grabación. Dicho reloj será accesible dentro de la plantilla \{\{$>$recordSubmit\}\}. Por lo que la sincronización con los cambios en el editor será perfecta. El proceso puede verse en el código de ejemplo \ref{code:eventsEditor}

\paragraph{}
Como puede verse en el código anterior, docsManagerRecorder es nuestro objeto construido mediante EditorManager y mediante su método .insertFunctions() generamos nuevas acciones que se simularán durante la reproducción en el instante almacenado en su atributo \emph{time}.

\paragraph{}
Puesto que una grabación debe estar formada por uno o más documentos, durante la grabación puede producirse la creación de nuevos documentos y del cambio de uno a otro sobre el editor. Estos cambios deben ser visibles durante la reproducción por lo tanto deben ser capturados. La captura se realiza mediante los eventos que se produzcan en la plantilla correspondiente al crearse un nuevo documento o visualizar otro distinto al actual. En el momento que alguno de estos eventos se produzca se generará una nueva acción que insertar en la lista de acciones mediante el método .insertFunctions(). 
\paragraph{}
Los eventos posibles que se traducen en acciones son los siguientes: 
\begin{itemize}
	\item Borrar: se borra contenido.
	\item Insertar: se inserta contenido.
	\item Selección: cambia la selección del cursor.
	\item Cursor: cambia la posición del cursor.
	\item Scroll: cambia la altura del scroll.
	\item Creación documento: el usuario crea un nuevo documento.
	\item Cambio de documento: el usuario selecciona otro documento distinto al actual para su visualización.
\end{itemize}

\subsubsection{Almacenamiento}
Como podemos observar en la figura \ref{fig:recordProcess}, una vez termina la grabación se deben proporcionar herramientas para su almacenamiento persistente. El almacenamiento de dicha grabación se realizará por separado según sus componentes. Un objeto record compuesto por información sobre la grabación y la lista de acciones (\ref{recordMongo}) se almacenará en la colección Records de MongoDB y el archivo de audio en SoundCloud. 
\paragraph{}
Para utilizar la API de SoundCloud es necesaria la instalación de un nuevo paquete: \textbf{monbro:soundcloud-nodejs-api-wrapper}  . Este paquete es un wrapper (envoltorio) del \textbf{SDK} (Software Development Kit) de SoundCloud que permite realizar llamadas REST a la API desde el lado del servidor gracias al objeto SoundCloud que nos proporciona de manera global. 
\paragraph{}
Para inicializar dicho objeto necesitaremos un usuario en SoundCloud y crear una aplicación en su espacio para desarrolladores. Dicha aplicación nos proporcionará una serie de credenciales que nos permitirán comunicarnos con la API: identificador de la aplicación, clave secreta de la aplicación. Al crearla necesitaremos proporcionarle una url de redirección para la autenticación mediante el protocolo \textbf{OAuth}. 
\paragraph{}
Usando solamente el SDK en el cliente, a la hora de conectar con la API, comenzaría un proceso de autenticación que mostraría un popup que exige interacción con el usuario. Dicho proceso no es transparente al usuario y eso es algo que hemos querido arreglar. La solución es incorporar como parámetro de incialización del SDK un \textbf{token} OAuth (el devuelto tras el proceso de autenticación). El problema está en que dicho token tiene una fecha de expiración y el SDK para Javascript no proporciona herramientas para refrescar el token ya que no tiene método para realizar esa petición REST en cuestión. Pero el paquete mencionado anteriormente sí tiene esa funcionalidad, y es que cada vez que llamamos a su método .getClient(), nos devuelve un cliente con un token completamente nuevo. 
\paragraph{}
Por este motivo creamos el fichero \emph{/app/server/soundcloud.js} en el que inicializar el objeto SoundCloud y crear el method .getClientSC() al que podemos llamar desde el cliente y que nos devuelve los parámetros necesarios para incializar el SDK del cliente de forma que se conecte a la API de SoundCloud de forma transparente al usuario (código de ejemplo \ref{code:SCSettings}).

\paragraph{}
Las variables CLIENT\_ID Y CLIENT\_SECRET contienen el id de la aplicación que hemos creado en Soundcloud y su clave secreta respectivamente.
\paragraph{}
Una vez que tenemos inicializado el SDK en el cliente podemos realizar la subida del audio de la siguiente manera: 
\begin{lstlisting}[language=Javascript]
var recordMongoObject = {};
SC.connect().then(function(){
	SC.upload({
		file: recorder.getAudio(), //Blob
		title: 'title'
	}).then(function(track){
		recordMongoObject.track = {
			id: track.id,
			link: track.uri
		}
		//llamada al servidor para almacenar el objeto.
	})
})
\end{lstlisting}
\paragraph{} 
En el código anterior se muestra cómo se crea una referencia al archivo subido mediante su identificador. Una vez tenemos el objeto completado realizamos la llamada al method insertRecord, creado en el archivo \emph{/app/lib/collections/records.js} para almacenar la grabación en MongoDB.


\subsubsection{Interfaz del grabador}
La interfaz del grabador está formado por dos espacios: la pantalla en la que se mostrará una plantilla u otra dependiendo de las acciones a realizar y una caja con botones que determinarán dichas acciones. Además, como se graban documentos sobre editor, constará de una pestaña en la que aparecerá el título del documento que está siendo editado y un botón para acceder a la lista de documentos como se muestra en la figura \ref{fig:recorderBase}

\paragraph{}
El diseño del grabador se compone de las siguientes plantillas: 
\begin{itemize}
	\item \textbf{\{\{$>$initial\}\}}: es la que se muestra inicialmente y consta de un botón para mostrar la lista de documentos.
	\item \textbf{\{\{$>$documentList\}\}}: se muestra como un panel dentro de la pantalla de la interfaz y contiene un botón para mostrar el formulario de creación de documentos y la lista de documentos creados. Al hacer click en cada uno de ellos lo visualizaremos en la pantalla. Cada miniatura de los documentos posee un enlace de edición que muestra el formulario de creación con los datos del propio documento.
	\item \textbf{\{\{$>$documentForm\}\}}: es el formulario de edición y creación de los documentos. Se deberá introducir un título, un lenguaje de programación y un tema para el editor (estos dos últimos son opcionales).
	\item \textbf{\{\{$>$editor\}\}}: plantilla en la que se muestra el editor con el contenido de los documentos.
	\item \textbf{\{\{$>$actions\}\}}: esta plantilla está presente a lo largo de todo el proceso de grabación y determina las acciones a realizar según el estado del mismo (grabar, parar, guardar/cancelar).
	\item \textbf{\{\{$>$final\}\}}: al finalizar la grabación se muestra en la pantalla de la interfaz un mensaje.
	\item \textbf{\{\{$>$saveForm\}\}}: es el formulario para guardar nuestra grabación. Se deberá introducir un título y opcionalmente una descripción y una lista de etiquetas mediante un auto-completado de etiquetas que se ha elaborado.
	\item \textbf{\{\{$>$upload\}\}}:  al hacer click en guardar en la plantilla anterior se mostrará el progreso de subida del audio y cuando termine un mensaje y un enlace a la página de la grabación (reproductor) para reproducir la grabación.
\end{itemize}
\paragraph{}
Tras este análisis hemos encontrado una nueva entidad: \textbf{etiquetas} (Tags) por lo que creamos una nueva colección y un nuevo fichero en \emph{/app/lib/collections/tags.js} de forma análoga con las anteriores. Establecemos que una grabación puede tener o no etiquetas y que son globales es decir que la misma etiqueta la pueden tener una o varias grabaciones. Esta relación puede verse en el diagrama \ref{fig:ERdesign}. Además para tenerlas accesibles desde el formulario debemos crear una publicación a la que se subscribirá el cliente. Como es la primera, creamos el fichero \emph{/app/server/publications.js}. Será el fichero en el que declararemos todas nuestras publicaciones. La subscripción a esta publicación se hará dinámicamente puesto que se trata de un \textbf{auto-completado}.
\paragraph{}
El flujo de plantillas se muestra en la figura \ref{fig:grabacionFlujo}
Las plantillas presentes en la figura anterior corresponden a las figuras: \ref{fig:recorderNoDocs}, \ref{fig:recorderDocsList}, \ref{fig:documentForm}, \ref{fig:recorderEditor}, \ref{fig:recorderFinal} y \ref{fig:uploadProcess} disponibles en el apéndice \ref{appendix:mockupsApendix}.
\paragraph{}
Una vez desarrollado el grabador el resultado puede verse en la figura \ref{fig:recorder}.

\subsection{Reproductor}
\subsubsection{Ruta, publicaciones y subscripciones}
El reproductor es un módulo de la página de cada grabación que se establece en una nueva ruta de nuestro proyecto y la primera que establecemos como detalle (detail). La ruta será /record/:id donde id corresponderá al identificador del objeto grabación almacenado en MongoDB y estará configurada en /app/lib/router.js de la misma forma que las anteriores. 
\paragraph{}
La única diferencia es que ahora necesitaremos tener accesible el objeto grabación para realizar las acciones oportunas. Esto se consigue creando publicaciones y subscripciones (ejemplos de código \ref{code:publishcomposite} y \ref{code:subscription}). De esta manera tendremos accesibles los datos del record y se establecerán como los datos de la plantilla \{\{$>$record\}\}.

\subsubsection{Proceso de reproducción}
Debido a que cada grabación está compuesta por audio y por vídeo sobre editor, se desarrollan dos procesos paralelos y sincronizados durante la reproducción de la misma (figura \ref{fig:playProcessSched}).
\begin{itemize}
	\item \textbf{Audio:} nos conectamos a SoundCloud y realizamos la petición del stream del audio correspondiente.
	\item \textbf{Vídeo (editor):} a medida que el audio se reproduce, se realiza la simulación de cada evento capturado durante la grabación de forma sincronizada.
\end{itemize}

\begin{figure}[h]
    \centering
    \subfigure[Esquema]{
   	 \includegraphics[width=0.8\textwidth]{playProcess.png}
    	\label{fig:playProcessSched}
    }
    \subfigure[Lógica]{
    	\includegraphics[width=0.8\textwidth]{playProcessObjects.png}
	 \label{fig:playProcessLogic}
    }
    \caption{Proceso de reproducción}
    \label{fig:playProcess}
\end{figure}

\paragraph{}
Al igual que durante la grabación, la labor de reproducción de cada una de las componentes recaerá en un objeto Javascript: \textbf{RecordPlayer} (audio) y \textbf{EditorPlayerManager} (editor) en los ficheros \emph{/app/client/lib/recordPlayer.js} y \emph{/app/client/lib/editorPlayerManager.js} respectivamente (figura \ref{fig:playProcessLogic}).
\begin{itemize}
	\item \textbf{RecordPlayer:} se encarga de ofrecer una interfaz lógica a partir del stream del audio proporcionado en su inicialización. Dicha interfaz recoge los métodos necesarios para la reproducción (.play(), .pause(), .seek(), .setVolume(), .ended()) y otros propios (.updateCover(), .getState(), .destroy()).
	\item \textbf{EditorPlayerManager:} se encarga de clasificar la lista de acciones capturadas y realizar su simulación. Además se encarga de mantener la integridad de los documentos de la grabación durante el proceso. Este objeto posee los métodos .getDocs(), .getDocActual(), .update() y .seek().
\end{itemize}
 

\subsubsection{Sincronización entre audio y editor}

Al inicializar el objeto RecordPlayer toma como argumento un objeto EditorPlayerManager ya inicializado con el identificador del editor. El método .play del objeto RecordPlayer inicia una llamada a su función .updatePlayer() mediante un Interval de 20. Esto quiere decir que cada 20 milisegundos se ejecutará esta función que, a su vez, realiza una llamada a la función .update() del objeto EditorPlayerManager pasado como argumento. Por lo que cada 20 milisegundos se mostrarán cambios en el contenido del editor.

\paragraph{}
Al llamar al método .pause() de RecordPlayer se destruirá la programación del objeto Interval, con lo que parará de inmediato los cambios sobre el editor. 
\paragraph{}
Al saltar entre instantes de la reproducción se llamará al método .seek(). Este método realiza una llamada directa al método .updatePlayer() y por tanto al método .update() de EditorPlayerManager, pasando como parámetro el instante exacto.

\subsubsection{Simulación de eventos sobre editor}
La simulación se realiza en el método .update() del objeto EditorPlayerManager. El objeto posee la lista de acciones completa, la cual no se alterará en ningún momento. Al inicializarse se realiza una copia en una variable global del objeto. En el momento que se produce la llamada al método .update() dicha lista se filtra (se escogen las acciones cuyo instante de creación sea menor o igual que el instante actual de la reproducción). Después se clasifican estas acciones y se ejecutan en orden. Después se actualiza el valor de la variable donde estaba la copia de las acciones eliminando de esa lista los ya simuladas. Este proceso se ilustra en el código de ejemplo \ref{code:sincroEditor}. 

\subsubsection{Interfaz del recurso grabación}
\paragraph{}
Se trata de un recurso de detalle (detail resource) y en este proyecto se ha hecho un diseño base (figura \ref{fig:detailBase}) para este tipo de recurso basado en tres espacios: 
\begin{itemize}
	\item {Banner: } este será el espacio dedicado para la presentación de la información relativa al objeto correspondiente al recurso.
	\item {NavbarTab: } barra de navegación basada en tabs para elegir qué contenido, asociado al objeto, visualizar.
	\item {tabContent: } espacio en el que se muestran el contenido escogido.
\end{itemize}
El banner, en este caso, mostrará la información de la grabación (autor, descripción, título, fecha de creación, contadores y lista de etiquetas), un botón para votar, la plantilla \{\{$>$player\}\} para el reproductor y la plantilla \{\{$>$actions\}\} como se muestra en el diseño (figura \ref{fig:recordBanner}).

\begin{figure}[htpb]
	\centering
	\includegraphics[width=0.6\textwidth, height=10cm]{RecordBanner.png}
	\caption{Diseño banner para una grabación}
	\label{fig:recordBanner}
\end{figure}

\subsubsection{Interfaz del reproductor}
\begin{figure}[htpb]
	\centering
	\includegraphics[width=0.7\textwidth]{playerV1}
	\caption{Diseño interfaz del reproductor}
	\label{fig:playerV1}
\end{figure}
La interfaz del reproductor (figura \ref{fig:playerV1})estará compuesta por el editor, una capa superpuesta vinculada a los eventos play y pause y la plantilla \{\{$>$playerActions\}\} en la que se muestra el progreso, el timer, un controlador de volumen y los botones play y pause cuando correspondan. Además en la parte superior aparecerá una pestaña en la que se mostrará información sobre el documento actual (título y lenguaje).
\subsubsection{Streamming}
La plantilla \{\{$>$player\}\} se instancia mediante un helper de la plantilla \{\{$>$record\}\} cuyo valor es un objeto Javascript con los datos necesarios para construir e inicializar los objetos RecordPlayer y EditorPlayerManager y el identificador del audio almacenado en SoundCloud. 
\paragraph{}
Como se muestra en el código de ejemplo \ref{code:SCConnection}, en el método .rendered() es necesaria la conexión con SoundCloud para realizar la petición de un stream de audio que poder suministrar al objeto RecordPlayer creado.

\paragraph{}
El resultado final del reproductor puede verse en la siguiente figura \ref{fig:recordPlayerPage}.

\subsection{Lista de grabaciones}
\subsubsection{Ruta, publicaciones y subscripciones}
La lista de grabaciones se mostrará en una nueva página o recurso de la aplicación. Dicho recurso corresponde a la ruta /records y a la plantilla \{\{$>$records\}\}. Como en cada nueva ruta es necesario integrarla en \emph{/app/lib/router.js} y, en este caso, crear las publicaciones y subscripciones necesarias.
\subsubsection{Interfaz}
La interfaz es muy sencilla (figura \ref{fig:recordsPage}). Está formada por dos espacios:
\begin{itemize}
	\item \textbf{logo:}  en este espacio se muestra el logo, el título de la lista y un enlace al recurso creación correspondiente.
	\item \textbf{\{\{$>$recordsTabContent\}\}:} este espacio será genérico para la aplicación y es que en cualquier parte de la aplicación que se quieran listar grabaciones se utilizará esta plantilla. Está formada por:
	\begin{itemize}
		\item \textbf{\{\{$>$contentNavbar\}\}:} en ella aparecen una serie de filtros (recientes, populares), opciones de visualización y un tab para iniciar el buscador.
		\item \textbf{\{\{$>$content\}\}:} en esta plantilla se listarán las grabaciones mediante miniaturas (figura \ref{fig:miniaturesRecord}) según el modo de visualización y aparecerá un botón para cargar más ítems.
	\end{itemize}
\end{itemize}

Tras el desarrollo de la interfaz el resultado se muestra en la figura \ref{fig:records}.

\section{Prototipo 3: Respuestas a grabaciones}
En este prototipo actualizamos la lógica del grabador y añadimos nuevas acciones para la página de detalle de grabación. En este prototipo se ha realizado la extracción de los requisitos expuestos en \ref{rRec}
\subsection{Actualización del grabador}
Las respuestas a grabaciones se realizan mediante nuevas grabaciones sobre editor según los requisitos de la aplicación. La única diferencia es que esta vez el grabador se debe iniciar con los documentos de la grabación a la que queremos responder. Además el contenido de dichos documentos debe corresponder al instante en el que hemos pausado la reproducción. 
\paragraph{}
Para todo lo anterior necesitamos inicializar, con el estado de dichos documentos, al objeto que se encarga de manejarlos durante la grabación (EditorManager).  Pero antes necesitamos extraer dicho estado durante la reproducción. Para esto el objeto recordPlayer cuenta con el método .getState() que devuelve un objeto con el último instante de reproducción y la lista de documentos con su estado actual. Dicho objeto se almacenará en una variable de sesión accesible desde el fichero \emph{/app/lib/router.js}. 
\paragraph{}
Para inicializar el objeto EditorManager como se ha descrito, necesitamos tener esos documentos accesibles desde los datos de la plantilla \{\{$>$recordSubmit\}\}. De esto se encarga Iron Router. La forma de especificar nuestra intención de realizar una grabación respuesta a Iron Router es mediante una \textbf{query string} (cadena de consulta). En ella se especificará el identificador de la grabación a la que queremos responder y la clave será \emph{parent\_id} (código de ejemplo \ref{code:dataByQuery}).
\paragraph{}En el código anterior podemos ver cómo se configuran los datos de la plantilla del grabador y cómo nos subscribimos a los documentos de la grabación padre.
\paragraph{}
Hay que tener en cuenta que en el momento que abandonemos la página del grabador, la variable de sesión deberá ser destruida. Esto supone un problema. Si abandonamos la página del grabador y después volvemos a ella, Iron Router interpreta que queremos hacer una grabación respuesta. Esto se debe a que la query string no desaparece. Por este motivo se ha establecido que si volvemos al grabador se comenzará con los documentos en el estado final de la grabación padre. Dichos documentos los tenemos accesibles gracias a la publicación correspondiente y a la subscripción mediante el método .waitOn() de la ruta descrita en el código.
\paragraph{}
Como se muestra en el objeto (\ref{recordMongo}), cuando almacenemos la respuesta en MongoDB debemos incluir dos campos: \emph{isReply} y \emph{parent\_id}. 
\subsection{Nuevas acciones}
En la plantilla \{\{$>$actions\}\} de la interfaz de detalle de grabación (figura \ref{fig:recordBanner}) creamos dos botones: uno como enlace al grabador para crear una respuesta (sólo estará disponible si la reproducción se encuentra pausada o finalizada) y otro como enlace a la grabación padre (sólo disponible si se trata de una respuesta).
\vspace{0.5cm}
\begin{lstlisting}[language=HTML]
<div id='actions'>
	{{#if isPosibleToReply}}
		<button id='reply-button'>reply</button>
	{{/if}}
	{{#if isReply}}
		<button id='go-to-parent-button'>parent</button>
	{{/if}}
</div>
\end{lstlisting}
\vspace{0.5cm}
\begin{lstlisting}[language=Javascript]
Template.record.events({
	'click button#reply-button': function(){
		Session.set('playerState',this.recordPlayer.getState());
		Router.go('recordSubmit',{},{query: 'parent_id=' + this._id});
	},
	'click button#go-to-parent-button': function(){
		Router.go('record',{_id: this.parent_id});
	}
});
\end{lstlisting}

En el código anterior podemos apreciar la lógica del proceso descrito anteriormente.
\subsection{Timeline, relacionados y comentarios}
En este prototipo se han generado las secciones de contenido de la página detalle de una grabación mostradas en la figura \ref{fig:detailBase}: \{\{navbarTab\}\}(figura \ref{fig:navbarTabDesign}) y \{\{tabContent\}\}. La plantilla \{\{navbarTab\}\} se ha diseñado como componente de manera que pueda ser configurada con las tabs que correspondan para cada página de detalle.

\paragraph{}
Para listar las respuestas de una grabación se ha creado un timeline (figura \ref{fig:repliesTab}). Dicho timeline se muestra al seleccionar la tab Replies del \{\{$>$navbar\}\} de la página de la grabación.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\textwidth]{repliesTab.png}
	\caption{Diseño de timeline}
	\label{fig:repliesTab}
\end{figure}

\paragraph{}Además se ha añadido una nueva sección de contenidos para mostrar las grabaciones relacionadas con la grabación actual (figura \ref{fig:relatedTab}). Para ello se ha modificado la publicación 'record'. Ahora publicará, además de la grabación actual, otras que posean etiquetas similares.

\paragraph{}
Dicho timeline puede visualizarse de manera dinámica en lo que al proceso de reproducción se refiere. Cuando el instante de reproducción coincide con el inicio de la grabación de una respuesta, aparecerá una miniatura en un módulo de sugerencias. Dicha miniatura será un enlace al recurso de detalle de dicha grabación.

\paragraph{}También se ha creado una nueva sección que contiene un espacio para realizar comentarios (figura \ref{fig:commentsTab}) y con ello surge una nueva entidad. Dicha entidad se traduce en una nueva colección Comentarios cuyo objeto se muestra en \ref{commentMongo} y su relación con las demás entidades en la figura \ref{fig:ERdesign}. Esta sección esta compuesta por una caja para introducir el texto a publicar y la lista de comentarios. Cada comentario está compuesto por el avatar del autor, el texto, una lista de las respuestas a ese comentario y la misma caja de texto mencionada anteriormente responder.

\paragraph{}
Se ha diseñado el espacio para comentarios de manera que sea genérico, es decir, que se pueda utilizar para todo tipo de contenidos. Tras la implementación el resultado puede verse en las figuras \ref{fig:replies-tab} y  \ref{fig:comments-module}.

\section{Prototipo 4: Organización en Canales}
En este prototipo aparece por primera vez el concepto de organización en canales. La implementación de este concepto deberá cumplir todos los requisitos establecidos en \ref{rChan} correspondientes. 

\subsection{Concepto, entidades y modificaciones}
Un canal es un espacio público en el que crear grabaciones. Al ser público cualquier usuario puede acceder a sus contenidos de forma inmediata. También ofrece la posibilidad de crear comentarios, subscribirse y de votar. 
\paragraph{}
Con esta descripción surgen dos nuevas entidades: canales y subscripciones. Dichas entidades se traducen, al igual que las anteriores, en las colecciones Channels y UsersEnrolled respectivamente, cuyos objetos MongoDB son \ref{channelMongo} y \ref{userEnrolledMongo}. Para cada colección se crea un fichero en \emph{/app/lib/collections} de la misma forma que para las anteriores. La relación entre entidades se muestra en la figura \ref{fig:ERdesign}.
\paragraph{}
Puesto que el contenido del canal se constituye en base a las grabaciones, esa relación deberá reflejarse en los objetos de las mismas. Para ello contarán con el atributo channel\_id las grabaciones pertenecientes a los canales como puede verse en \ref{recordMongo}. Como se describió en el proceso de grabación, una vez terminada la grabación y completado el proceso de uploading a SoundCloud se procedía con la creación de un objeto grabación. En esta fase habrá que determinar si la grabación que se ha realizado pertenece a un canal o es independiente. Para ello utilizamos query strings o cadenas de consulta que incluimos en la url del recurso grabador. En este caso la query será \emph{channel\_id$=$idValue}. A modo de ejemplo y siendo el identificador del canal en el que queremos crear una nueva grabación la cadena \emph{QwIJOpIsAXzc} la url del recurso grabador sería \emph{/records/submit?channel\_id$=$QwIJOpIsAXzc}. Iron Router provee herramientas que permiten realizar esta función de forma sencilla (código de ejemplo \ref{code:createChannelRecordingByQuery}).
\subsection{Rutas y subscripciones}
Los canales, al ser un contenido más en la aplicación deberán de tener un recurso de creación y su propio recurso. Además contarán con un recurso de edición para cambiar la configuración del mismo.
Estos recursos serán: \emph{/channels}, \emph{/channels/submit}, \emph{/channel/:\_id} y \emph{/channel/:\_id/edit}. 
\paragraph{}
Tanto en el recurso de edición como en el propio del canal necesitaremos subscribirnos a los contenidos del canal correspondientes. Por esto creamos una nueva publicación en \emph{/app/server/publications.js} compuesta por todos los contenidos. A saber: el propio canal, los usuarios subscritos y las grabaciones y comentarios del mismo. Para el recurso de edición sólo es necesario algunos campos del objeto MongoDB del canal. Por lo que creamos una nueva publicación para esta información. En el recurso \emph{/channels} necesitaremos subscribirnos a los datos informativos de todos los canales del sitio. Para ello crearemos otra publicación compuesta.
\subsection{Diseño de interfaces e implementación}
\subsubsection{Creación de un canal}
La información básica de un canal estará formada por un título, una descripción y una lista de etiquetas. La interfaz de creación de un canal deberá permitir la introducción de dicha información (figura \ref{fig:createChannel}). Utilizamos el sistema de formularios dinámicos basados en variables de sesión que describimos en el prototipo 1 y el complemento de etiquetas que diseñamos en el prototipo 2 para la plantilla \{\{$>$saveForm\}\}. Además creamos un nuevo method en el servidor al que llamaremos desde el cliente para almacenar el objeto canal una vez introducida la información necesaria. (código de ejemplo \ref{code:createChannel}).
\begin{figure}[htpb]
	\centering
	\includegraphics[width=0.7\textwidth]{createChannel.png}
	\caption{Formulario de creación para un canal.}
	\label{fig:createChannel}
\end{figure}
\subsubsection{Página de canales}
Este es la página correspondiente al recurso \emph{/channels} y en ella los usuarios podrán navegar por la lista de canales del sitio. Su diseño (figura \ref{fig:channelsPage}) es equivalente al diseño de la lista de grabaciones y se compone de un logo, un enlace al recurso de creación y un sistema de tabs para realizar filtros y mostrar resultados. Este recurso estará accesible desde el sidebar como se muestra en la versión 3 del mismo (figura \ref{fig:sidebarVersions}).
\subsubsection{Página del canal}
Al tratarse de un recurso de detalle, el diseño base de la interfaz será el mostrado en la figura \ref{fig:detailBase}. En el \{\{banner\}\} aparecerá el título del canal, su descripción, la lista de etiquetas, un logo, una imagen de fondo, un enlace al recurso de edición y una caja en la que se mostrará la información de su creador. Además incorporará la plantilla \{\{actions\}\} que permitirá subscribirse o cancelar la subscripción y votar dicho canal (figura \ref{fig:channelBanner}).
\begin{figure}[htpb]
	\centering
	\includegraphics[width=0.7\textwidth]{ChannelBanner.png}
	\caption{Diseño del banner de un canal}
	\label{fig:channelBanner}
\end{figure}
\paragraph{}
El \{\{navbarTab\}\} contendrá las tabs (figura \ref{fig:navbarTabDesign}): 
\begin{itemize}
	\item \textbf{Recordings:} si se selecciona se mostrarán en \{\{contentTab\}\} las grabaciones pertenecientes al canal. Dichas grabaciones podrán ser filtradas por los filtros recientes y populares. Además aparecerá un enlace al recurso de creación para una grabación.
	\item \textbf{Comments:} mostrará la lista de comentarios realizados.
	\item \textbf{Users:} mostrará la lista de usuarios subscritos.
\end{itemize} 
\subsubsection{Edición de un canal}
En este recurso se podrá editar la descripción, el logo, la imagen de fondo y la lista de etiquetas del canal. Utilizamos el sistema de formularios dinámicos mediante la inclusión de la plantilla \{\{$>$awesomeForm\}\}. Al tratarse del primer recurso de edición que nos encontramos en el proyecto, diseñamos una plantilla base (figura \ref{fig:editFormBase}) que podremos reutilizar en cada recurso de este tipo. Dicha plantilla se basa en la incorporación dinámica de complementos o componentes que desarrollaremos para cada tipo de información y que nos permitirá editarlos. 
\paragraph{}
La entrada y la salida de datos de dicho formulario será una variable de sesión que configuraremos en la plantilla del recurso de edición correspondiente. El valor de dicha variable será un objeto con la información actual del objeto a editar y con una serie de configuraciones que hará que se muestren unos complementos u otros. En este momento se desarrollan los siguientes complementos: 
\begin {itemize}
	\item \textbf{AvatarEdit: } permitirá la edición de cualquier tipo de imagen. Las opciones serán establecer una por defecto, escoger una desde el disco o introducir una url.
	\item \textbf{DescriptionEdit: } con este complemento editaremos cualquier información basada en texto mediante un textarea.
	\item \textbf{TagsEdit: } con este complemento editaremos la lista de etiquetas. Además incorpora el sistema búsqueda de etiquetas ya desarrollado.
\end {itemize}
\paragraph{}
El diseño de estos complementos y el del formulario pueden verse en las figuras \ref{fig:formEditComplements} y \ref{fig:channelEdit} correspondientemente.



\section{Prototipo 5: Organización en Lecciones}
En este prototipo aparece por primera vez el concepto de organización en lecciones. La implementación de este concepto deberá cumplir los requisitos establecidos en \ref{rLess}.

\subsection{Concepto, entidades y modificaciones}
Una lección es un espacio privado en el que crear grabaciones. Esta privación se traduce en que la creación de contenido inmediato para cada lección recae en la figura del usuario creador y que el contenido es privado para los usuarios que no estén subscritos a la misma. Además la estructuración del contenido de cada lección estará basada en secciones.
\paragraph{}
Con la anterior descripción surgen dos nuevas entidades: \textbf{lecciones} y \textbf{secciones}. Estas entidades se traducen en las colecciones Lessons y Sections cuyos objetos son \ref{lessonMongo} y \ref{sectionMongo} respectivamente. Se crean los ficheros \emph{/app/lib/collections/lessons.js} y \emph{/app/lib/collections/sections.js} en los que se declararán las colecciones y se implementarán los methods para gestionar sus modificaciones. Su relación con las demás entidades se muestra en la figura \ref{fig:ERdesign}.
\paragraph{}
Cada sección estará compuesta de grabaciones. Por lo que dichas grabaciones harán referencia a la sección y a la lección que pertenecen, además de indicar el orden dentro de la sección. Cada sección poseerá también un orden dentro de cada lección. Estos parámetros serán necesarios a la hora de editar las listas en el recurso de edición de la lección. Al igual que para las grabaciones pertenecientes a un canal, informamos al grabador de que se trata de una grabación perteneciente a una lección mediante la url. Esta vez formada por varias query string: \emph{lesson\_id}, \emph{section\_id} y \emph{order} (\ref{recordMongo} y código de ejemplo \ref{code:createRecordingFromLesson}). 

\subsection{Rutas y subscripciones}
Los recursos que se establecen para este contenido son: \emph{/lessons/submit}, \emph{/lessons}, \emph{/lesson/:\_id} y \emph{/lesson/:\_id/edit} (creación, listado, propio y creación).
\paragraph{}
Creamos una publicación compuesta para el recurso detalle, una publicación simple para el recurso de edición y otra compuesta para el recurso de listado a las que nos subscribiremos mediante el método .waitOn() de cada ruta establecida en \emph{/app/lib/router.js} para cada recurso.
\subsection{Lista de reproducción y opciones}
\begin{figure}[htpb]
	\centering
	\includegraphics[width=0.7\textwidth]{playlist.png}
	\caption{Diseño lista de reproducción}
	\label{fig:playlist}
\end{figure}
Debido a que el contenido de las lecciones se estructura en secciones que no son más que una lista de grabaciones, introducimos el concepto de lista de reproducción para el proyecto. Esto es, cuando reproduzcamos una grabación perteneciente a una lección, el reproductor mostrará la lista de grabaciones de la sección a la que pertenece. Además permitirá la navegación por ella y establecer las opciones de reproducción y repetición automática. 
Estas configuraciones se realizarán en el objeto del usuario mediante los atributos: \emph{auto\_play} y \emph{auto\_repeat}. Las funciones son las siguientes: 
\begin {itemize}
	\item \textbf{Reproducción automática: } al terminar la reproducción de cada elemento de la lista se comienza con la del siguiente.
	\item \textbf{Repetición automática: } convierte la lista de grabaciones en una lista circular. El elemento siguiente del último es el elemento primero y el elemento anterior al primero es el último.
\end{itemize}
\paragraph{}
Si se da el caso de que ambas funciones están activadas, la reproducción de la lista de grabaciones de una sección es infinita.
El diseño de la misma puede verse en la figura \ref {fig:playlist}.
\subsection{Diseño de interfaces e implementación}
\subsubsection{Creación de una lección}
La información básica de una lección está formada por un titulo, una descripción y una lista de tags. Para su implementación utilizamos el sistema de formularios dinámicos mediante variables de sesión e integramos en la plantilla del formulario (figura \ref{fig:createChannel}) los complementos que permitan la introducción de dicha información (los mismos que para el recurso de creación de un canal).
\subsubsection{Página de lecciones}
En esta página los usuarios podrán explorar las lecciones del sitio. Su diseño (figura \ref{fig:lessonsPage}) esta formado por un logo, un enlace al recurso de creación para las lecciones y un sistema de tabs. Este sistema de tabs es el mismo que hemos desarrollado para la página de las grabaciones. Este recurso estará accesible desde el sidebar como se muestra en la versión 3 del mismo (figura \ref{fig:sidebarVersions}).
\subsubsection{Página de una lección}
\begin {figure}[htpb]
	\centering
	\includegraphics[width=0.7\textwidth]{LessonBanner.png}
	\caption{Diseño del banner de una lección}
	\label{fig:lessonBanner}
\end{figure}
Al tratarse de un recurso de detalle, tendrá el mismo diseño base que con los que comparte dicha clasificación (figura \ref{fig:detailBase}). En el \{\{banner\}\} aparecerá el título de la lección, el logo, la descripción, un apartado con la información sobre el autor y los contadores de la lección, la lista de etiquetas y la plantilla \{\{actions\}\} que permitirá a los usuarios realizar determinadas acciones según su rol: 
\begin{itemize}
	\item \textbf{Autor: } podrá votar y acceder al recurso de edición.
	\item \textbf{Visitante: } si está subscrito podrá votar y cancelar su subscripción y, si por el contrario, no lo está, podrá subscribirse.
\end{itemize}
\paragraph{}
El \{\{navbarTab\}\} contendrá las tabs (figura \ref{fig:navbarTabDesign}):
\begin{itemize}
	\item \textbf{Sections: } si se encuentra seleccionada, en \{\{contentTab\}\} se mostrará el listado de las secciones y un botón para acceder a un modal con el formulario para crear las mismas.
	\item \textbf{Comments: } lista de comentarios de la lección.
	\item \textbf{Users: } lista de usuarios subscritos.
\end{itemize}
\paragraph{}
Cada ítem sección estará formado por una cabecera y por un sistema de tabs implementado mediante un \textbf{collapsible} de Bootstrap. Ciertas acciones sobre estos elementos serán accesibles o no dependiendo del rol del usuario basándonos en los requisitos establecidos. Esto se refleja en la figura \ref{fig:sectionsTab}. Cada ítem en su cabecera mostrará el número de grabaciones, un botón para eliminar la sección, un botón para reproducir los contenidos y un enlace al recurso de creación de las grabaciones (grabador). El sistema de tabs estará formado por dos pestañas. En una aparecerá la lista de grabaciones (enlaces al reproductor) y en la otra la lista de grabaciones con botones para editar el orden dentro de la sección. Todas las acciones que pretendan crear, modificar o borrar están suprimidas para los usuarios con el rol de visitante.
\subsubsection{Edición de una lección}
Al tratarse de un recurso de edición, utilizamos el diseño implementado anteriormente. La plantilla \{\{$>$awesomeForm\}\} para cargar el formulario base mostrado en la figura \ref{fig:editFormBase} y a dicho formulario integramos los componentes (figura \ref{fig:formEditComplements}) avatarEdit, descriptionEdit, tagsEdit y además creamos uno nuevo para poder editar el orden de las secciones. El diseño se muestra en la figura \ref{fig:lessonEdit} 

\section{Prototipo 6: Página de perfil y Contactos}
En este prototipo se ha diseñado e implementado la página de perfil del usuario y un espacio para realizar solicitudes de contacto y mostrar esas relaciones entre los distintos usuarios. Los requisitos extraídos se corresponden con los mostrados en \ref{rProf}.
\subsection{Perfil}
Se trata de un nuevo módulo y recurso cuya ruta será \emph{/profile/\_id}, donde \emph{\_id} corresponderá al id del usuario en cuestión. Se crean nuevas publicaciones y subscripciones y se establece la ruta en \emph{/app/lib/router.js}.

\subsubsection{Interfaz}
Al tratarse de un recurso de detalle compartirá la misma base que los demás (figura \ref{fig:detailBase}). El \{\{banner\}\} estará formado una cabecera en la que se muestran el avatar del usuario, una imagen de fondo, un botón para acceder al recurso de edición del perfil y una caja con acciones y un cuerpo en el que aparece el nombre de usuario, la descripción y lista de servicios (figura \ref{fig:profileBanner}). 

\begin{figure}[htpb]
	\centering
	\includegraphics[width=0.8\textwidth]{profileBanner.png}
	\caption{Diseño banner del perfil}
	\label{fig:profileBanner}
\end{figure}

\subsubsection{Contenidos}
Utilizamos el complemento navbarTab y lo configuramos para que tenga las tabs canales, lecciones, grabaciones, conversaciones y contactos que corresponden a las categorías de contenido de la aplicación (figura \ref{fig:navbarTabDesign}).
Podemos reutilizar las plantillas  \{\{contentTab\}\} para mostrar las listas de contenido según la categoría que hemos generado para los recursos \emph{/records}, \emph{/channels} y \emph{/lessons}. Sólo aparecerán las del usuario en cuestión, ya que nos hemos subscrito a sus contenidos. Aunque en este caso no existe la opción de iniciar el buscador, sino que se añaden nuevos filtros (figuras \ref{fig:recordsPage}, \ref{fig:lessonsPage} y \ref{fig:channelsPage} ): 
\begin{itemize}
	\item \textbf{Subscrito: }muestra los canales o lecciones a los que se ha subscrito el usuario según corresponda.
	\item \textbf{Historial: }muestra un total de 10 entradas. Dichas entradas serán las 10 últimas reproducciones que el usuario haya visualizado y formarán parte del  \{\{contentTab\}\} para las grabaciones.
\end{itemize}
\paragraph{}
Además se han incluido nuevos enlaces en el sidebar para acceder a los contenidos del perfil de forma directa mediante una query string que establece el contenido a visualizarse al cargar el perfil como puede verse en el diseño MenuTabV4 del sidebar (figura \ref{fig:sidebarVersions}). También se han incluido los enlaces necesarios en todas las cajas de usuario de los recursos detalle y en sus miniaturas.
\subsubsection{Roles}
Al visualizar cualquier página de perfil un usuario puede adoptar uno de estos dos roles: 
\begin{itemize}
	\item \textbf{Propietario:} lo adoptará el usuario que sea propietario de dicho perfil. Podrá acceder a la lista de servicios y al recurso de edición del perfil, además en cada \{\{contentTab\}\} se le mostrará un enlace al recurso de creación correspondiente. 
	\item \textbf{Visitante:}  lo adoptará el usuario que no sea propietario de dicho perfil. Podrá acceder a las acciones presentes en la cabecera del banner. Sólo existirá una, de momento: realizar peticiones de contacto.
\end{itemize}
\subsubsection{Edición del perfil}
Al igual que para editar las lecciones o los canales se establece un nuevo recurso para editar el perfil cuya ruta es \emph{/profile/:\_id/edit}. Como en las otras es necesario declararla en \emph{/app/lib/router.js} crear una nueva plantilla \{\{$>$profileEdit\}\} en \emph{/app/client/modules/profile\_modules/profileEdit/profileEdit.html} y subscribirse al usuario correspondiente. Al igual que los demás recursos de edición, éste mantiene el diseño base (figura \ref{fig:editFormBase}), es decir, que incorpora la plantilla \{\{$>$awesomeForm\}\} la cual, mediante una variable de sesión, carga uno u otro formulario con características comunes. En este caso, el formulario de edición dinámico creado en el prototipo 4. Además incorporamos los componentes avatar, banner y description (figuras \ref{fig:profileEdit}, \ref{fig:formEditComplements}). 
\subsection{Contactos}
Al existir usuarios en la aplicación es necesario establecer y denominar las relaciones entre ellos. Dichas relaciones se denominan relaciones de contacto. Con esto surge una nueva entidad (\textbf{Contactos}) que se traduce en una nueva colección Mongo llamada \textbf{Relations} con su fichero correspondiente y cuyo objeto es \ref{relationMongo}. La relación con las demás entidades se muestra en la figura \ref{fig:ERdesign}.


\subsubsection{Peticiones y lista de contactos}
Surge una nueva entidad Peticiones que se traduce en la colección llamada Requests cuyo objeto es \ref{requestsMongo} 
Para el \{\{contentTab\}\} del tab 'contactos'  del \{\{navbarTab\}\} de la página de perfil se establecen dos nuevas tabs: contactos y peticiones.
\paragraph{}
Para la tab contactos activa se mostrará la lista de los contactos (figura \ref{fig:contactsTab}). Cada miniatura contará con el avatar, el nombre de usuario, la fecha desde la que se inició la relación de contacto, la descripción y acciones (sólo visibles cuando el usuario es el propietario del perfil).

\paragraph{}
Para la tab peticiones activa se mostrará el espacio para peticiones (figura \ref{fig:requestsTab}). Dicho espacio esta compuesto por: 
\begin{itemize}
	\item Autocompletado: para buscar los usuarios. Cada resultado dispondrá de un botón para enviar la petición. Este botón se sustituirá por iconos de estado si la petición ya ha sido realizada. 
	\item Bandeja de entrada: se muestran las peticiones recibidas, su estado y acciones relacionadas con su estado.
	\item Bandeja de salida: se muestran las peticiones enviadas, su estado y acciones relacionadas con su estado.
\end{itemize}

Las acciones dependiendo del estado y de la bandeja en la que se encuentren se muestran en la tabla \ref{tabla:requestsActions}: 

\begin{table}[htb]
\centering
\begin{tabular}{|l|l|l|}
\hline
& \multicolumn{2}{c|}{Acciones} \\
\hline
Estado & Recibidas & Enviadas\\
\hline
Pendiente & Aceptar o Rechazar & X\\ \hline
Aceptada & Ok & Ok\\ \hline
Rechazada & X & Ok o Reenviar \\ \hline
\end{tabular}
\caption{Acciones para las peticiones}
\label{tabla:requestsActions}
\end{table}

El proceso para establecer la relación de contacto es la siguiente: 
\begin{enumerate}
	\item El usuario A envía una solicitud al usuario B y visualiza esta petición como pendiente.
	\item El usuario B visualiza la petición como pendiente en su bandeja de entrada y puede aceptarla o rechazarla.
	\item El usuario B acepta la petición y la visualiza como aceptada, pulsa Ok. Se crea la relación.
	\item El usuario A visualiza la petición como aceptada, pulsa Ok para eliminar la entrada.
\end{enumerate}

\paragraph{}Si el usuario B rechaza la petición, el usuario A la visualizaría como rechazada y podría pulsar Ok o reenviarla y comenzar el proceso de nuevo.

\paragraph{}Además de realizar las peticiones mediante este espacio, se habilita para los usuarios que tengan el rol de visitante un botón en \{\{actions\}\} como se muestra en la figura (\ref{fig:profileBanner}).

\paragraph{}La implementación de este prototipo tiene como resultado las figuras (\ref{fig:profile-page}, \ref{fig:profile-edit}, \ref{fig:contacts-tab} y \ref{fig:contacts-requests}).


\section{Prototipo 7: Conversaciones y alertas}
En este prototipo se ha diseñado y desarrollado el módulo de comunicaciones interno de la aplicación basado en conversaciones o chats. También el sistema de alertas y avisos de nuevos mensajes. La implementación se ha realizado partiendo de los requisitos \ref{rConv}.
\subsection{Conversaciones}
\subsubsection{Entidades, Rutas, subscripciones y publicaciones}
Se trata de otra categoría de contenidos dentro de la aplicación por lo que tendrá un recurso de creación, de detalle y de edición: \emph{/conversation/submit}, \emph{/conversation/:\_id} y \emph{/conversation/:\_id/edit}. El acceso a las conversaciones es privada, es decir, sólo los miembros pueden visualizarlas. Esto se traduce en que el listado de las mismas está disponible como contenido dentro del recurso perfil de cada usuario y sólo será visible si el usuario tiene el rol de propietario.
\paragraph{}
Con la aparición de esta nueva categoría surgen las nueva entidades \textbf{Conversaciones} y \textbf{Mensajes} que se traducen en las colecciónes \textbf{Conversations} (\emph{/app/lib/collections/conversations.js}) y \textbf{Messages} (\emph{/app/lib/collections/messages.js}) y cuyos objetos se definen en \ref{conversationMongo} y \ref{messageMongo}. La relación de éstas con las demás entidades queda reflejada en la figura \ref{fig:ERdesign}.
\paragraph{}
Al igual que para las anteriores categorías, se han creado las publicaciones necesarias a las que nos subscribiremos mediante Iron Router en las rutas establecidas a los recursos de detalle y de edición.
\subsubsection{Roles}
Los roles en las conversaciones serán importantes a la hora de ofrecer a los usuarios diferente funcionalidad. Los miembros de una conversación se pueden clasificar según sus roles en:
\begin{itemize}
	\item \textbf{Líder: } tiene acceso a todas las características de la conversación. Podrá expulsar usuarios, cambiar el asunto, añadir a nuevos miembros como invitados e, incluso, delegar su rol a otro miembro.
	\item \textbf{Invitados: } éstos tendrán acceso a las mismas funciones que el líder a excepción de expulsar usuarios y de cambiar el asunto.
\end{itemize}
\subsubsection{Creación de una conversación}
Puesto que las conversaciones son privadas, el único medio para acceder a su recurso de creación es desde el recurso perfil. Al igual que los anteriores, este recurso utiliza la plantilla \{\{$>$awesomeForm\}\} que mediante la variable de sesión 'typeForm' incluirá la plantilla base para un formulario de edición. Esta plantilla incorporará los componentes correspondientes para la introducción de la información necesaria. Estos son una caja de texto para el asunto y dos complementos que se han implementado para la introducción de miembros y del primer mensaje (figura \ref{fig:createConversation}).

\subsubsection{Página de conversación}
Este será el primer y único recurso de detalle que no compartirá con los demás el diseño base formado por un \{\{banner\}\}, \{\{navbarTab\}\} y \{\{contentTab\}\}. El diseño corresponderá al mostrado en la figura \ref{fig:conversationDesign} que se compone de tres espacios: 
\begin{itemize}
	\item \textbf{Cabecera: } aquí se mostrará toda la información relevante de la conversación (asunto, lista de miembros, contadores), botones para para visualizar el panel de miembros, el panel de opciones y acceder al recurso de edición.
	\item \textbf{Cuerpo: } corresponde a la lista de mensajes de la conversación. Los escritos por el usuario actual aparecerán a la derecha y los de los demás miembros a la izquierda. Cada mensaje poseerá información sobre su autor (nombre de usuario y avatar) y la fecha en la que se escribió.
	\item \textbf{Pie: } en este espacio aparecerá una caja de texto para la introducción de mensajes, unos botones para visualizar la lista de emoticonos y la introducción de enlaces y un botón para enviar. 
\end{itemize}
\paragraph{}
En el panel de miembros podremos ver la lista completa de usuarios que tienen accesible la conversación y acceder a sus perfiles.
\paragraph{}
El panel de opciones se adaptará al rol del usuario correspondiente. Las acciones disponibles son: editar, añadir más usuarios, borrar el historial de mensajes, expulsar miembros y dejar la conversación.
\paragraph{}
Partiendo del hecho de que las conversaciones deben tener un líder, si un usuario con este rol decide dejar la conversación deberá delegar su rol a otro miembro y después salir.
\subsubsection{Edición de una conversación}
Para este recurso se utilizará el mismo diseño de plantillas que para los anteriores recursos de edición. El formulario diseñado para este recurso (figura \ref{fig:conversationEdit}) integrará nuevos componentes: 
\begin{itemize}
	\item \textbf{\{\{subjectEdit\}\}: } complemento para editar el asunto.
	\item \textbf{\{\{leaderEdit\}\}: } permite escoger entre los miembros de la conversación al nuevo líder.
	\item \textbf{\{\{membersEdit\}\}: } permite editar los miembros (añadir y borrar).
\end{itemize}
El diseño de estos componentes o complementos y de los paneles de la conversación pueden verse en las figuras \ref{fig:conversationComplements} y \ref{fig:conversationPanels} respectivamente.
\subsection{Alertas}
\subsubsection{Concepto y entidades}
Partiendo del requisito de que los usuarios deben estar informados en todo momento de lo que ocurre en las conversaciones, se ha desarrollado un módulo de alertas de conversación. Estas alertas se generarán en el momento que se introduzca un nuevo mensaje en cualquier conversación y se mostrarán a todos aquellos usuarios miembro que no se encuentren visualizando la página de dicha conversación. El espacio dedicado a la visualización de las distintas alertas será una pestaña del sidebar (figura \ref{fig:sidebarConversations}). De este modo los usuarios podrán visualizarlas en cualquier momento. 
\paragraph{}
Este concepto supone una nueva entidad llamada Alertas de Conversación que se traduce en la colección conversationAlerts (\emph{/app/lib/collections/conversationAlerts.js}) cuyo objeto MongoDB se muestra en \ref{conversationAlertMongo}. La relación de esta entidad con las anteriores puede verse en el esquema de la figura \ref{fig:ERdesign}. 

\subsubsection{Proceso}
Al crearse una conversación se generan tantas alertas como miembros posea y su atributo \emph{alertsAllow} tendrá un valor inicial de \emph{true}. 
En el momento que un miembro accede a la conversación ese atributo se tornará a false. Creamos una publicación a la que los usuarios estarán subscritos en todo momento. Se basa en publicar las alertas de conversación que tengan el atributo alertsAllow a true. Además contará con la referencia a la conversación de la que proceden por lo que para cada alerta se mostrará el último mensaje (código de ejemplo \ref{code:conversationAlerts}). 
\paragraph{}
El resultado de la implementación de este prototipo puede verse en las capturas \ref{fig:conversation-create}, \ref{fig:conversation-page} Y \ref{fig:conversation-edit}.

En el siguiente capítulo se expondrán las pruebas de validación correspondientes realizadas tras el despliegue de la aplicación.