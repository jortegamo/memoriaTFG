\chapter{MongoDB y MeteorJS}\label{appendix:meteor}
En este apéndice se describe de forma detallada los principales fundamentos de MongoDB y su relación con MeteorJS.

\section{MongoDB}
\emph{MongoDB}\cite{bazMongoDB} es una base de datos \textbf{no relacional} cuya arquitectura \emph{se basa en documentos}. Al no ser \emph{relacional} como \textbf{mySQL}, \textbf{Oracle} o \textbf{PostgreeSQL} carece de \emph{claves primarias}. No hay que declarar un \emph{modelo de datos} puesto que lo que se almacenan son objetos en formato \textbf{BSON}\footnote{\url{http://bsonspec.org/}} (Binary JSON\footnote{\url{https://es.wikipedia.org/wiki/JSON}}) en el que todos los \emph{atributos} pueden ser utilizados como \emph{clave} a la hora de realizar búsquedas. Cada vez que un documento es insertado se le asocia un \emph{índice único}. Aunque no sea relacional ofrece la posibilidad de realizar un diseño de este tipo. Esto es enlazando objetos pertenecientes a \emph{colecciones} (tablas) diferentes mediante su identificador o cualquier atributo válido. La gran ventaja de utilizar este tipo de base de datos es la \textbf{rapidez de acceso}. Como cualquier \emph{objeto javascript} un documento puede \emph{embeber} otros documentos (objetos) a los que se les puede establecer un índice y realizar \textbf{búsquedas indexadas}. Además \emph{MongoDB} cuenta con módulos como \emph{\$agregation} que permite establecer reglas para cada colección que permiten realizar búsquedas más complejas como por ejemplo establecer para qué campo del documento se realiza una búsqueda mediante \emph{expresiones regulares}. 
\paragraph{}
Debido a que es una base de datos no relacional podemos \emph{embeber entidades} que dependan de otras en éstas. De no hacerlo así el proceso de \emph{borrado de datos} hay que tomarlo con calma debido a que este tipo de base de datos no posee \textbf{joins} ni de herramientas que hagan que la \textbf{atomicidad} de los datos se mantenga como ocurre en las bases de datos relacionales. Aunque si queremos también realizar un diseño desde un enfoque más limpio deberíamos de separar todas las entidades.

\subsection{MongoDB y MeteorJS}
\paragraph{}
Al crear una aplicación mediante el CLI de MeteorJS directamente se crea una base de datos MongoDB. Aunque Meteor no trabaja con otro tipo de base de datos en un principio, se puede cambiar mediante la instalación de paquetes. En la actualidad existen paquetes de bases de datos relacionales para Meteor que poseen reactividad y es este principio en el que se basa 
Meteor. 
\paragraph{}
Las tablas creadas en MongoDB en Meteor se convierten en colecciones, un wrapper para ofrecer funcionalidad desde la aplicación y dotarlas de reactividad (las convierte en fuentes reactivas). Este objeto en el que se engloba a la tabla o entidad ofrece los métodos \emph{.find()}, \emph{findOne()}, \emph{update()}, \emph{remove()}, \emph{insert()}, \emph{allow()} y \emph{deny()} que son los más usados. Hay que tener en cuenta que las colecciones en Meteor se declaran en la carpeta \emph{/lib}, cuyo contenido será ejecutado tanto en el entorno del cliente como en el del servidor. Esto quiere decir que cada entorno tendrá una instancia de cada colección y esto al igual que es ventajoso en cuanto a rapidez en el cliente (puede acceder a la base de datos directamente "miniMongo" ), es peligroso por el mismo motivo. Para ello existen los métodos \emph{deny()} y \emph{allow()} que establecen qué operaciones sobre la colección están permitidas en el cliente y cuáles no. 
\paragraph{}
Lo más sensato es permitir insertar y denegar el permiso para realizar cualquier alteración sobre otros documentos ya presentes, al menos directamente. Para ello se usa el módulo methods de Meteor que permite configurar métodos a los que llamar desde el cliente (también se declaran en la carpeta \emph{/lib}) y que se ejecutan en el servidor (donde no existe ningún tipo de restricción).

\section{Publicaciones y Subscripciones}
\paragraph{}
Puesto que las instancias de las colecciones se encuentran accesibles también en el cliente debe haber un control sobre el contenido de las mismas dentro de MiniMongo. Para ello se utilizan las publicaciones y las subscripciones.
Las publicaciones se realizan en el lado del servidor y el cliente se subscribe a ellas. La moneda de cambio son los cursores. Un cursor es una fuente reactiva que engloba uno, varios o ningún documento procedente de una colección. El cliente al subscribirse a una publicación obtiene el cursor y este lo transforma en documentos que se almacenan dentro de MiniMongo donde tendrá accesibles los documentos. Lo bueno de esto es que como se ha dicho los cursores son fuentes reactivas, esto quiere decir que en el momento que se produzca algún cambio que altere el cursor al que se está subscrito, la publicación cambiará y la subscripción se actualizará. Para aprovecharse de este fenómeno el cliente necesita extraer un cursor procedente de MiniMongo mediante \emph{NombreColección.find()} o \emph{NombreColección.findOne()} y asociarlo a un helper dentro de la lógica de la plantilla.