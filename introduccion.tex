%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%                  															       %%%%%%
%%%%%%%                                                     CAPITULO 1:  INTRODUCCIÓN                                       %%%%%%
%%%%%%%  																	       %%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introducción}
\paragraph{}
Este Trabajo Fin de Grado se desarrolla en el ámbito del desarrollo y tecnologías web. En este capítulo introduciremos los conceptos y tecnologías básicas utilizadas y expondremos el paradigma actual en lo que a desarrollo web se refiere.
\section{Desarrollo Web}
\paragraph{}
En la actualidad el desarrollo web se encuentra muy arraigado en nuestra sociedad. Avanza a una velocidad increíble, tanto que ni nos percatamos de su impacto en todo lo que nos rodea. Acogemos cada nueva tecnología con los brazos abiertos y al poco transcurso de tiempo desde su primer uso nos es insuficiente. Esa insuficiencia impulsa su crecimiento e impide su decadencia. 
\paragraph{}
Para conocer la historia del desarrollo web es necesario remontarse a los orígenes de \emph{Internet}. En 1969 se crea la primera red de comunicación interconectada entre dos computadoras de dos universidades estadounidenses (UCLA y Stanford) llamada \textbf{ARPAnet}\footnote{https://es.wikipedia.org/wiki/ARPANET} (Advanced Research Projects Agency Network o Red de la Agencia para los Proyectos de Investigación Avanzada de los Estados Unidos) que funcionaba con un protocolo de intercambio de paquetes llamado \textbf{NCP}\footnote{\url{https://en.wikipedia.org/wiki/Network_Control_Program}} (Network Control Program) y que más tarde se sustituyó por \textbf{TCP/IP}\footnote{\url{https://es.wikipedia.org/wiki/Modelo_TCP/IP}} por su robustez frente a colisiones. En 1986 comenzó la construcción de la primera infraestructura en forma de árbol de Internet llamada \textbf{NSFNET}\footnote{\url{https://es.wikipedia.org/wiki/NSFNet}} la cual se complementó con otras redes en EEUU. Después se crearon otras redes troncales en Europa y junto con las anteriores ya formaban el \emph{backbone} o red troncal básica de Internet. Más tarde, en 1989 con la creación de la arquitectura de capas OSI en los computadores, comenzó a ser tendencia el utilizar diversos protocolos de comunicación a través de dicha red.  
\paragraph{}
El desarrollo web se inició con la propia web o lo que conocemos como \textbf{WorldWideWeb}\footnote{\url{https://es.wikipedia.org/wiki/World_Wide_Web}} (WWW) que fue el primer cliente web creado por el \emph{CERN}, cuyo equipo también creó el lenguaje \emph{HTML}\footnote{\url{https://es.wikipedia.org/wiki/HTML}} (HyperText Markup Language). Lenguaje básico a la hora de estructurar la información en un sitio web.
\paragraph{}
El desarrollo web comprende todo el proceso de creación de un sitio web. La elección de las herramientas a utilizar, de diseño y desarrollo, qué metodología seguir, prototipado, propuesta final y lanzamiento. Es una labor compleja transformar una idea en algo físico y dotarla de utilidad para la sociedad. Es un reto que yo, como alumno, nunca había tenido la oportunidad de afrontar y me alegro de haber tenido la ocasión de realizar este proyecto.
\paragraph{}
La labor del desarrollador web en la actualidad es mucho más sencilla y accesible gracias a las tecnologías que surgen cada pocas semanas o días. Con el término \emph{open source} en auge, millones de usuarios de Internet quieren aportar su granito de arena a esta labor y propician un crecimiento en herramientas web increíble y en ocasiones vertiginoso. 
\section{Tecnologías Web}
Entran en este ámbito todas aquellas herramientas creadas específicamente para generar contenido web. Según su finalidad dentro del desarrollo web podemos diferenciarlas en Frameworks, librerías y lenguajes.
\paragraph{}
\subsection{Frameworks}
Según su definición un \textbf{framework}\footnote{\url{https://es.wikipedia.org/wiki/Framework}} es un \emph{conjunto de conceptos y prácticas estandarizados} diseñado para afrontar un problema en particular, en este caso, el proporcionar una \emph{infraestructura de software} a la hora de crear una aplicación web. Al usar un framework debemos seguir una serie de reglas establecidas según su diseño a la hora de organizar el código. Hoy en día estamos siendo testigos de la \emph{"Batalla de los frameworks"} en lo que a desarrollo web se refiere y es que su crecimiento y potencial es increíble. Es muy importante conocer los puntos fuertes y débiles de cada uno de ellos a la hora de diseñar una aplicación ya que no todos incorporan los mismos conceptos y prácticas. Además también es imprescindible entender el \emph{entorno de ejecución} de cada uno de ellos a saber: cliente (\textbf{Front-End]}), servidor (\textbf{Back-End})\footnote{\url{https://es.wikipedia.org/wiki/Front-end_y_back-end}} o ambos (\textbf{Full Stack}).

\paragraph{}
En la actualidad se utilizan numerosos frameworks entre los que destacan: \textbf{AngularJS}\footnote{\url{https://angularjs.org/}}, \textbf{EmberJS}\footnote{\url{http://emberjs.com/}}, \textbf{Django}\footnote{\url{https://www.djangoproject.com/}}, \textbf{ReactJS}\footnote{https://facebook.github.io/react/}, \textbf{MeteorJS}\cite{baz5}, \textbf{BackboneJS}\footnote{\url{http://backbonejs.org/}} y \textbf{ExpressJS}\footnote{\url{http://expressjs.com/es/}}. Todos utilizan \emph{Javascript}\footnote{\url{https://es.wikipedia.org/wiki/JavaScript}} como lenguaje de desarrollo a excepción de Django que utiliza \emph{Python}\footnote{\url{https://www.python.org/}}. 

\subsubsection{AngularJS}
\paragraph{}
Es un framework front-end. Hace posible realizar peticiones REST y se pueden desarrollar \emph{proveedores} que brindan servicios al cliente que se encuentran en el lado del servidor. La principal característica de Angular es que mediante su concepto de \emph{directiva} podemos construir toda la aplicación de forma modular. Además cuenta con \emph{two data-binding }que permiten el \emph{renderizado reactivo} y dinámico de sus plantillas o módulos.
\paragraph{}
AngularJS es una creación de Google y es el framework más utilizado hoy en día, por lo que posee una gran comunidad, y uno de los más pesados en lo que respecta a tamaño.
\subsubsection{EmberJS}
\paragraph{}
Se trata de un framework front-end muy potente diseñado para crear aplicaciones grandes. Mediante la librería \textbf{Handlebars} \footnote{\url{http://handlebarsjs.com/}} que incorpora podremos crear plantillas dinámicas gracias al \emph{data-binding} que presenta. Además también posee un \emph{CLI} (Interfaz de Línea de Comandos) que nos permitirá configurar todo mediante comandos. Posee el módulo de \emph{routing} más avanzado de todos los frameworks. Es una excelente herramienta para desarrollar un cliente con un buen nivel de potencial.
\subsubsection{Django}
\paragraph{}
Django, al igual que Ruby on Rails o MeteorJS no se debería de considerar framework sino \emph{plataforma} de desarrollo web, ya que es full-stack y posee su propio CLI. El lenguaje de desarrollo es Python. Posee todas las herramientas necesarias para generar un servidor y un cliente. Es una herramienta muy completa. En el momento de su lanzamiento experimentó una gran acogida y aún conserva su fama tras sus numerosas actualizaciones.
\subsubsection{ReactJS}
\paragraph{}
Este es el framework más limitado en lo que a ámbito de ejecución se refiere (desarrollo de  las vistas en el cliente y poco más). Pero es increíblemente \emph{flexible}. La forma en la que se crean las plantillas en ReactJS (sin necesidad de escribir HTML) es increíble. Ha sido creado por Facebook y se utiliza cada vez más por su concepto de reactividad.
\subsubsection{MeteorJS}
\paragraph{}
MeteorJS \cite{baz5}, como decíamos de Django, se le debería tratar como una plataforma de desarrollo. Corre sobre \textbf{NodeJS}\footnote{\url{https://nodejs.org/en/}} y la principal ventaja que ofrece es que el servidor es completamente transparente al desarrollador. Solo debe preocuparse de crear el modelo de datos (más bien enunciarlo porque cuenta con \textbf{MongoDB}\cite{baz10} como base de datos), las rutas, las \emph{publicaciones} de datos reactivos y de las plantillas de la aplicación. Ha sido el pionero en lo que respecta al concepto de \emph{reactividad} antes que ReactJS. Es una herramienta a tener en cuenta por su gran comunidad y sus paquetes específicos y por su capacidad para el \emph{prototipado} rápido.
\paragraph{}
Exploraremos más a fondo las características de este framework más adelante ya que es el framework elegido para el desarrollo de nuestra aplicación que es de lo que trata este proyecto.
\subsubsection{BackboneJS}
\paragraph{}Se trata de otro de los frameworks front-end más usados en la actualidad y no es de extrañar debido a su sencillez y capacidad. Es ideal para aplicaciones pequeñas y medianas.
\subsubsection{ExpressJS}
\paragraph{}
Este es un framework back-end y permite crear un servidor NodeJS en pocos minutos para sólo preocuparse del desarrollo front-end. Actualmente tiene cabida en cualquier proyecto por su fácil integración con cualquiera de los frameworks front-end.
\subsubsection{Bootstrap \cite{baz8}}
\paragraph{}
Es más una \emph{librería} que un framework pero dado que posee un paradigma especial y unas reglas claras a la hora de usarlo se le considera un framework front-end. Permite el dotar a tu aplicación de estilo rápidamente puesto que ya tiene definidos estilos por defecto, y crear módulos funcionales para organizar el contenido, además de animaciones. Está destinado a la labor de maquetación y es el más utilizado hoy en día. Aunque también se utilizan otros como \textbf{Foundation} \footnote{\url{http://foundation.zurb.com/}} o \textbf{Pure} \footnote{\url{http://purecss.io/}} que también poseen buenas características para dicha labor.

\subsection{Librerías}
\paragraph{}
Las librerías son un \emph{conjunto de utilidades programadas} en un lenguaje dado que proporcionan un \emph{servicio concreto} al desarrollador. Al contrario que un programa no están pensadas para un uso automático, es decir, no tienen un inicio. Sólo son usadas por programas. En lo que se refiere a desarrollo web son utilizadas para aportar servicios al desarrollador de la aplicación. La librería líder en este ámbito es \textbf{JQuery}\cite{baz11}\cite{baz12} y sus descendientes como \textbf{JQueryUI} \footnote{\url{https://jqueryui.com/}}. Otra libería cada vez más utilizada es \textbf{UnderscoreJS}.
\subsubsection{JQuery}
\paragraph{}
Se trata de una librería que permite manipular el \emph{DOM}\footnote{\url{https://es.wikipedia.org/wiki/Document_Object_Model}} (Document Object Model) desde la lógica de la aplicación. No necesitamos hacer uso del objeto document para realizar búsquedas, añadir etiquetas y demás operaciones de manipulación. Mediante JQuery podremos establecer eventos, manipular dinámicamente el DOM añadiendo etiquetas y estilos y mucho más. Es una herramienta indispensable para el desarrollador web. Lo es tanto que incluso otras librerías y paquetes destinados a diferentes frameworks la usan.
\subsubsection{UnderscoreJS \cite{baz13}}
\paragraph{}
Esta es una librería que permite manipular objetos, colecciones de objetos y arrays. Permite realizar \emph{operaciones de filtrado} muy avanzadas sobre una colección de objetos y además realizar iteraciones de forma funcional mediante sus métodos 


\subsection{Lenguajes}
\paragraph{}
Existen numerosos lenguajes en desarrollo web: \textbf{Java} (para servidores principalmente), \textbf{Javascript}, \textbf{CoffeeScript}, \textbf{TypeScript}, \textbf{HTML5}, \textbf{Jade}, \textbf{CSS}, \textbf{Less}, \textbf{Sass}, \textbf{Python}, \textbf{Ruby}, etc. Pero hay que tener en cuenta que lo que el navegador compila e interpreta son ficheros CSS, HTML y lenguajes de lógica de la aplicación como Javascript. Por lo que si desarrollamos con Jade, Less, Sass, CoffeeScript o TypeScript debemos de preprocesarlos hacia los tres principales lenguajes mencionados anteriormente.
\subsubsection{HTML5}
\paragraph{}
Se trata de la quinta versión del lenguaje HTML. Posee una variante de sintaxis básica conocida como HTML5 y otra \textbf{XHTML} conocida como XHTML5 y se sirve como sintaxis \textbf{XML} \footnote{\url{http://www.w3schools.com/xml/}} (eXtensible Markup Language) concebido por el \textbf{World Wide Web Consortium} \footnote{\url{https://es.wikipedia.org/wiki/World_Wide_Web_Consortium}}(W3C) con el fin de almacenar datos de forma legible y que complementa en la mayoría de aplicaciones al documento HTML. 
\paragraph{}
En esta quinta versión se han desarrollado nuevas etiquetas que ayudan a realizar un documento más semántico y legible, además de proporcionarnos herramientas de dibujo en 2D y 3D, etiquetas para introducir audio y video o de formato. Etiquetas como: \emph{$<$article$>$}, \emph{$<$aside$>$},\emph{ $<$audio$>$}, \emph{$<$video$>$}, \emph{$<$canvas$>$}, \emph{$<$datalist$>$}, \emph{$<$details$>$}, \emph{$<$dialog$>$}, \emph{$<$embed$>$}, \emph{$<$figure$>$}, \emph{$<$footer$>$}, \emph{$<$header$>$}, \emph{$<$mark$>$}, \emph{$<$meter$>$}, \emph{$<$nav$>$}, \emph{$<$output$>$}, \emph{$<$progress$>$}, \emph{$<$ruby$>$}, \emph{$<$rp$>$}, \emph{$<$rt$>$}, \emph{$<$section$>$}, \emph{$<$source$>$} y \emph{$<$time$>$}. 
\paragraph{}
También incorpora herramientas nuevas como un visor de fórmulas matemáticas (\textbf{MathML}), tecnología \textbf{Drag \& Drop} (arrastrar y soltar objetos basado en eventos), ejecución en paralelo mediante \textbf{WebWorkers}, comunicación bidireccional entre páginas mediante \textbf{WebSockets}, \textbf{APIs} para almacenamiento (\textbf{Local \& Global Storage}), \textbf{geolocalicación} y para trabajar sin conexión (\textbf{Off-line}).
\paragraph{}
La incorporación de estas nuevas herramientas reduce la necesidad del desarrollador a utilizar \emph{plugins} externos.
\subsubsection{CSS3}
\paragraph{}
CSS es el lenguaje utilizado para crear la presentación y dar estilo al documento HTML o XML. En esta tercera versión se introducen nuevas funcionalidades como animaciones 3D, transiciones, estructuración mediante propiedades \emph{grid} (rejilla), \emph{media querys} para establecer cambios de estilo conforme el tamaño de la pantalla varía, etc.
\subsubsection{Javascript \cite{baz9}}
\paragraph{}
Es el lenguaje de programación más usado hoy en día en el desarrollo web (sobretodo en el lado del cliente). Fue creado por \emph{Brendan Eich} de \textbf{Netscape} como dialecto de \textbf{ECMAScript} \footnote{\url{https://en.wikipedia.org/wiki/ECMAScript}}. Su primer nombre fue \emph{Mocha}, después \emph{LiveScript} y finalmente Javascript. Es un lenguaje orientado a objetos, basado en \textbf{prototipos}, funcional (las funciones son objetos), posee un \emph{tipado} muy débil y es dinámico. 
\paragraph{}
Como se ha comentado, el marco de utilización de este lenguaje en el desarrollo web son los frameworks front-end. Aunque también se utilizan frameworks basados en NodeJS o el propio NodeJS para desarrollar mediante este lenguaje en el lado del servidor en numerosos proyectos. 
\paragraph{}
Javascript sigue creciendo y actualizándose. En 2015 fue lanzado el estándar \textbf{ECMAScript6} \footnote{\url{http://www.campusmvp.es/recursos/post/ECMAScript-6-es-ya-un-estandar-cerrado.aspx}}, el cual dota a javascript de nuevas funcionalidades y módulos como un nuevo paradigma de orientación a objetos basado en \textbf{clases}, iteradores o \textbf{promesas} para programación asíncrona.
\section{MeteorJS}
\paragraph{}
Meteor es una \emph{plataforma} que permite crear aplicaciones Web en \emph{tiempo real} basada en \textbf{NodeJS}. Fue creado con el propósito del \emph{prototipado rápido} y en este ámbito supera a la mayoría de \emph{frameworks}. Ha sido el primero en introducir el principio de \emph{reactividad} en el desarrollo web. Soporta \textbf{MongoDB} como tecnología de base de datos y posee un asombroso concepto de \emph{subscripciones} a \emph{publicaciones} procedentes de \emph{colecciones} que hacen del \emph{renderizado} del \textbf{DOM} un proceso muy rápido gracias a que mantiene en el cliente una mini base de datos llamada \emph{MiniMongo}. El cliente es capaz de modificar dicha base de datos y observar los cambios directamente que más tarde se actualizarán en la base de datos del servidor.

\subsection{Reactividad}
\paragraph{}
EL gran potencial de Meteor es debido a este \emph{principio}. Se basa en observar los cambios sobre una \emph{fuente} en tiempo real y actuar en consecuencia, dotando a las aplicaciones de un \emph{dinamismo} muy especial. Adiós a los \emph{Listeners} y al \emph{binding} sobre elementos \textbf{HTML}, no hacen falta si sabes aprovechar este principio y sus \emph{entidades}.
En meteor existen numerosas entidades que proveen \emph{reactividad} y otras muchas que permiten crear nuevas \emph{entidades reactivas}. Las \textbf{fuentes reactivas} que puedes controlar de manera simple en Meteor son las \emph{variables de sesión} almacenadas en \emph{Session}. Mediante la sentencia \emph{Session.set(key[String],value)} ya tienes una fuente reactiva a tu disposición. Sólo necesitas algo que sepa escuchar sus cambios y actuar (\emph{helpers} o \emph{Tracker}). 
\paragraph{}
El modulo \textbf{Tracker} posee un método \emph{.autorun()} que permite ejecutar código cuando una fuente reactiva cambia. Además puede directamente asociarse a la lógica de cualquier plantilla dentro del método \emph{.rendered()} del controlador. Esto permite dotar a la plantilla de dinamismo, por ejemplo realizar \textbf{subscripciones dinámicas} sobre una colección enlazado con los eventos de la plantilla. (Autocompletados basados en subscripciones, Botones para cargar más contenido, etc).
\subsection{Sistema de plantillas reactivas}
\paragraph{}
 Meteor utiliza una \emph{biblioteca} muy poderosa para crear \emph{interfaces de usuario} que se actualizan en tiempo real
llamada \textbf{Blaze} \footnote{\url{https://guide.meteor.com/blaze.html}}. Cumple el mismo propósito que \textbf{Angular}, \textbf{Backbone}, \textbf{Ember}, \textbf{React}, \textbf{Polymer} o \textbf{Knockout} en este ámbito
pero es mucho más sencilla de utilizar, incluso \emph{transparente} para el programador. Su labor no sería posible sin 
\emph{Tracker}, un módulo de Meteor que permite gestionar \emph{procesos reactivos} de manera limpia, y sin \textbf{Spacebars} \footnote{\url{http://meteorcapture.com/spacebars/}} 
(parecido a \textbf{Handlebars}), el lenguaje particular de Meteor para definir las plantillas y que aprovecha al máximo la funcionalidad
de \emph{Tracker}.
\subsection{Comunicación con el servidor}
\paragraph{}
La comunicación con el servidor se basa en el protocolo HTTP que Meteor integra de manera transparente al programador mediante su módulo \emph{methods} al que se accede mediante \emph{Meteor.methods()} y para la petición de recursos se utiliza algún paquete creador de rutas como \textbf{IronRouter}\cite{bazIronRouter} o \textbf{FlowRouter} \footnote{\url{https://github.com/kadirahq/flow-router}}. También posee el módulo \emph{http} para realizar peticiones desde el cliente al servidor y a terceros. Todas las peticiones son asíncronas y como tales se les asocian callbacks (funciones que se ejecutarán una vez haya terminado la ejecución de la petición).
\paragraph{}
Cada vez que se define una plantilla mediante Spacebars se crea un objeto plantilla Template.name y que lo tendremos accesible a la hora de dotarla de funcionalidad mediante javascript. Es un tipo de controlador. Spacebars permite el paso de datos de la plantilla al controlador y viceversa, esto se denomina \textbf{two data-binding} y supone una poderosa herramienta a la hora de crear componentes aislados puesto que su configuración puede realizarse vía Spacebars. Este proceso lo realiza mediante la declaración de helpers o ayudantes de plantilla y se definen mediante la función \emph{helpers()} del controlador. La gran ventaja de esto radica en que los helpers son funciones javascript asociadas a una fuente reactiva. Esto quiere decir que en el momento que esa fuente cambia los helpers se actualizan y se actualiza el contenido HTML asociado a ellos. Además de permitir crear componentes reusables, éstos son dinámicos (reactivos) en su instanciación y durante su uso.
\paragraph{}
Aparte de los helpers al controlador se le puede asociar un mapa de eventos relacionados con la plantilla mediante la función \emph{events()} que toma como parámetro un objeto javascript cuyos métodos definirán las funciones de los mismos.
\subsubsection{Jerarquía de carpetas y orden de carga}

\paragraph{}
Para aplicaciones pequeñas es posible escribir el código ejecutable por el cliente y por el servidor en una misma carpeta. Para ello Meteor cuenta con las funciones \emph{.isClient()} y .\emph{isServer()} para especificar qué código debe ejecutarse en cada entorno. Para aplicaciones más grandes la estructura es un poco peculiar y se debe generar teniendo en cuenta el orden de carga según la \emph{jerarquía de carpetas}. Este orden de carga aunque sea muy estricto provee de una flexibilidad asombrosa y permite crear cualquier aplicación de forma \emph{modular}. La jerarquía de carpetas sería la siguiente:
\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{hierarchyFolders.png}
    \caption{jerarquía de carpetas}
    \label{fig:hierarchyFolders}
\end{figure}

\paragraph{}
La carpeta \emph{/lib} de más alto nivel dentro de la jerarquía contiene todos los \emph{ficheros comunes} a ambos entornos (cliente y servidor) y es la primera en cargar. \emph{/server} y \emph{/client} contienen todos los \emph{ficheros ejecutables} por el servidor y por el cliente respectivamente. Dentro de cada una de las carpetas anteriores existe un orden de carga. Si poseen carpeta \emph{/lib} será la primera en cargar, después es el turno de los demás ficheros en \emph{orden alfabético} y, por último, los ficheros \emph{main.*} sea cual sea su extensión. En la carpeta \emph{/public} se encuentra el \emph{contenido estático} de nuestra aplicación (fuentes, imágenes, etc).

\paragraph{}
Como podemos ver según el orden y ámbito de ejecución Meteor ofrece un \emph{entorno de ejecución simétrico} (se ejecuta tanto en el cliente como en el servidor) dentro de la carpeta \emph{/lib} de más alto nivel en la jerarquía. La principal ventaja de esto es que no tenemos porqué replicar código. Podemos crear \emph{constructores} y demás funcionalidad necesaria en ambos entornos una sola vez y Meteor se encarga de saber que cargar en cada uno.
\paragraph{}
Además, al ser MeteorJS una plataforma de desarrollo, no es necesario un \emph{gestor de tareas} como \textbf{GruntJS}\footnote{\url{http://gruntjs.com/}} o \textbf{GulpJS}\footnote{\url{http://gulpjs.com/}}. Estos se encargan de \textbf{automatizar tareas} tales como establecer la carga de ficheros sobre el  \emph{documento HTML}, \emph{minificar} todos los ficheros, establecer la \emph{configuración del servidor} o arrancar nuestra aplicación. Meteor posee un \textbf{CLI} (Interfaz de línea de comandos) que mediante el comando \emph{meteor} ya se encarga de establecer las configuraciones iniciales, cargar todos los ficheros según el orden descrito e incluirlos en el documento y arrancar nuestro servidor. El \emph{minificado} no es necesario en un primer momento, puesto que con el \emph{deploying} (despliegue) se realizará. Existen una gran cantidad de paquetes y constructores que lo harán de forma automática. 

\section{MongoDB}
\emph{MongoDB}\cite{bazMongoDB} es una base de datos \textbf{no relacional} cuya arquitectura \emph{se basa en documentos}. Al no ser \emph{relacional} como \textbf{mySQL}, \textbf{Oracle} o \textbf{PostgreeSQL} carece de \emph{claves primarias}. No hay que declarar un \emph{modelo de datos} puesto que lo que se almacenan son objetos en formato \textbf{BSON}\footnote{\url{http://bsonspec.org/}} (Binary JSON\footnote{\url{https://es.wikipedia.org/wiki/JSON}}) en el que todos los \emph{atributos} pueden ser utilizados como \emph{clave} a la hora de realizar búsquedas. Cada vez que un documento es insertado se le asocia un \emph{índice único}. Aunque no sea relacional ofrece la posibilidad de realizar un diseño de este tipo. Esto es enlazando objetos pertenecientes a \emph{colecciones} (tablas) diferentes mediante su identificador o cualquier atributo válido. La gran ventaja de utilizar este tipo de base de datos es la \textbf{rapidez de acceso}. Como cualquier \emph{objeto javascript} un documento puede \emph{embeber} otros documentos (objetos) a los que se les puede establecer un índice y realizar \textbf{búsquedas indexadas}. Además \emph{MongoDB} cuenta con módulos como \emph{\$agregation} que permite establecer reglas para cada colección que permiten realizar búsquedas más complejas como por ejemplo establecer para qué campo del documento se realiza una búsqueda mediante \emph{expresiones regulares}. 
\paragraph{}
Debido a que es una base de datos no relacional podemos \emph{embeber entidades} que dependan de otras en éstas. De no hacerlo así el proceso de \emph{borrado de datos} hay que tomarlo con calma debido a que este tipo de base de datos no posee \textbf{joins} ni de herramientas que hagan que la \textbf{atomicidad} de los datos se mantenga como ocurre en las bases de datos relacionales. Aunque si queremos también realizar un diseño desde un enfoque más limpio deberíamos de separar todas las entidades.

\subsection{MongoDB y MeteorJS}
\paragraph{}
Al crear una aplicación mediante el CLI de MeteorJS directamente se crea una base de datos MongoDB. Aunque Meteor no trabaja con otro tipo de base de datos en un principio, se puede cambiar mediante la instalación de paquetes. En la actualidad existen paquetes de bases de datos relacionales para Meteor que poseen reactividad y es este principio en el que se basa 
Meteor. 
\paragraph{}
Las tablas creadas en MongoDB en Meteor se convierten en colecciones, un wrapper para ofrecer funcionalidad desde la aplicación y dotarlas de reactividad (las convierte en fuentes reactivas). Este objeto en el que se engloba a la tabla o entidad ofrece los métodos \emph{.find()}, \emph{findOne()}, \emph{update()}, \emph{remove()}, \emph{insert()}, \emph{allow()} y \emph{deny()} que son los más usados. Hay que tener en cuenta que las colecciones en Meteor se declaran en la carpeta \emph{/lib}, cuyo contenido será ejecutado tanto en el entorno del cliente como en el del servidor. Esto quiere decir que cada entorno tendrá una instancia de cada colección y esto al igual que es ventajoso en cuanto a rapidez en el cliente (puede acceder a la base de datos directamente "miniMongo" ), es peligroso por el mismo motivo. Para ello existen los métodos \emph{deny()} y \emph{allow()} que establecen qué operaciones sobre la colección están permitidas en el cliente y cuáles no. 
\paragraph{}
Lo más sensato es permitir insertar y denegar el permiso para realizar cualquier alteración sobre otros documentos ya presentes, al menos directamente. Para ello se usa el módulo methods de Meteor que permite configurar métodos a los que llamar desde el cliente (también se declaran en la carpeta \emph{/lib}) y que se ejecutan en el servidor (donde no existe ningún tipo de restricción).

\subsection{Publicaciones y Subscripciones}
\paragraph{}
Puesto que las instancias de las colecciones se encuentran accesibles también en el cliente debe haber un control sobre el contenido de las mismas dentro de MiniMongo. Para ello se utilizan las publicaciones y las subscripciones.
Las publicaciones se realizan en el lado del servidor y el cliente se subscribe a ellas. La moneda de cambio son los cursores. Un cursor es una fuente reactiva que engloba uno, varios o ningún documento procedente de una colección. El cliente al subscribirse a una publicación obtiene el cursor y este lo transforma en documentos que se almacenan dentro de MiniMongo donde tendrá accesibles los documentos. Lo bueno de esto es que como se ha dicho los cursores son fuentes reactivas, esto quiere decir que en el momento que se produzca algún cambio que altere el cursor al que se está subscrito, la publicación cambiará y la subscripción se actualizará. Para aprovecharse de este fenómeno el cliente necesita extraer un cursor procedente de MiniMongo mediante \emph{NombreColección.find()} o \emph{NombreColección.findOne()} y asociarlo a un helper dentro de la lógica de la plantilla.


\section{HTML5 Media}
Con la llegada y estandarización de HTML5 cada vez se trabaja más en herramientas que faciliten la comunicación entre usuarios y que, en definitiva, brinden servicios interactivos a los mismos en tiempo real. Una de esas herramientas es \textbf{WebRTC} \cite{baz1} (Web Real-Time Communication).
\subsection{WebRTC}
Se trata de una API creada para permitir realizar llamadas de voz, chat de video e intercambio de archivos \textbf{P2P} (Peer to Peer) sin la necesidad de \emph{plugins}. Es \textbf{Open Source} (Código abierto). Fue creado primero por Google y la W3C se encarga ahora de su estandarización. Su desarrollo está en proceso, por lo que se comporta de manera inestable en su funcionalidad avanzada.
Los navegadores que la soportan son Chrome, Firefox y Opera hoy en día. Esto se debe a que su módulo \textbf{navigator} facilita el acceso a los recursos media del ordenador (micrófono, webcam).
\subsection{RTCRecorder}
Se trata de una API \cite{baz2} basada en WebRTC que proporciona una serie de herramientas para grabar video y audio de manera sencilla y pudiendo exportar el archivo creado y almacenarlo tanto en servicios cloud como en local. El creador de esta API también ha desarrollado otros módulos basados en WebRTC capaces por ejemplo de grabar video y audio sobre un elemento canvas. Hablaremos de esta API más adelante puesto que ha sido integrada en el proyecto.
\section{AceEditor}
\paragraph{}
\textbf{AceEditor}\cite{AceEditor} es una API que permite transformar un contenedor HTML (por ejemplo un \emph{$<$div$>$}) en un editor de texto completo. Además proporciona una serie de métodos que permiten personalizarlo y \emph{capturar eventos} que se produzcan en dicho editor. Existen otras APIs parecidas como \textbf{CodeMirror}\footnote{\url{https://codemirror.net/}}, pero ésta posee más documentación y está disponible como paquete para Meteor \cite{AceEditorPackage}. Exploraremos más a fondo esta API más adelante.
\section{Tecnologías Cloud}
\paragraph{}
Hoy en día el término \emph{Cloud} está muy extendido. La mayoría de aplicaciones y sitios web utilizan tecnologías cloud para almacenar grandes cantidades de datos y liberar memoria propia de la aplicación o bien son utilizadas como base de datos. Ejemplos de tecnologías cloud son \textbf{Google Drive}, \textbf{Dropbox}, \textbf{Youtube}, \textbf{Amazon S3}, \textbf{Soundcloud}, \textbf{mLab} o \textbf{DigitalOcean}.
\paragraph{} La mayoría de los anteriores son utilizados como servicios cloud extra o para almacenar contenidos de la aplicación (ficheros, imágenes, audios, videos). Amazon S3 o mLab son utilizados como base de datos de la aplicación y su ventaja radica en que, a la hora de realizar el despliegue, utilizamos servidores externos en los que almacenaremos la base de datos de nuestra aplicación.
\subsection{API Soundcloud}
Soundcloud\footnote{\url{https://soundcloud.com}} es un sitio web que permite alojar archivos de audio al estilo de Youtube con vídeos. Posee un API disponible en diferentes lenguajes de programación como Ruby, javascript y PHP para realizar peticiones REST y por tanto un espacio para desarrolladores en el cual crear diferentes aplicaciones con las que comunicarse la API. Se trata de una solución factible a la hora de desarrollar un proyecto pequeño ya que tiene limitaciones en lo que respecta a espacio. Si nos encontramos ante un proyecto de gran envergadura necesitaremos explorar otras vías como \textbf{GridFS}\footnote{\url{https://docs.mongodb.com/manual/core/gridfs/}} aplicado a otro servicio cloud de base de datos como Amazon S3.  
\paragraph{} 
También proporciona herramientas de \textbf{Streaming} de gran utilidad a la hora de reproducir dichos archivos de audio en nuestra aplicación de forma remota.
\paragraph{}
Exploraremos a fondo esta API puesto que es una de las herramientas más importantes incluidas en este proyecto.

\section{Herramientas para trabajo en equipo}
El mundo del desarrollo web es altamente competitivo y como tal exige la obtención de resultados muy a corto plazo. Para conseguir este objetivo surgen las metodologías ágiles como \textbf{SCRUM}\footnote{\url{https://en.wikipedia.org/wiki/Scrum_(software_development)}} que, según su definición, no es más que un proceso en el que se aplican una sucesión de buenas prácticas para trabajar en equipo. La finalidad es conseguir un equipo altamente productivo. La base de esta metodología es la realimentación o feedback, es decir, es un proceso circular compuesto por varias fases y realimentado en el cual el cliente toma conciencia de cada ciclo aportando sus críticas. 
\paragraph{}
Para reforzar este proceso y facilitar la labor del desarrollador y de todo el equipo existen distintas herramientas como \textbf{GitHub}, \textbf{PivotalTracker} y \textbf{Slack} entre otras. Estas herramientas han sido utilizadas a lo largo de este proyecto.
\subsection{Git y GitHub}
\paragraph{}
Git es el sistema de control de versiones más usado en el mundo del desarrollo. Crea una copia del proyecto en un \textbf{repositorio} y a través de sus \textbf{commits} se almacenan versiones recuperables del mismo. Incorpora un sistema para generar \textbf{ramas} de versiones que posteriormente pueden volver a unirse para conformar el resultado final del proyecto o finalizar alguna fase. Esto lo hace verdaderamente potente a la hora de utilizarlo en grupo y por tanto es necesario compartir el repositorio entre los integrantes del equipo de desarrollo. Esto se hace mediante GitHub, una plataforma en la que almacenar proyectos públicos o privados que integra el sistema de control de versiones mencionado anteriormente. Permite la copia de cualquier versión desde un usuario a otro (\textbf{fork}) y puede desarrollarse un seguimiento de todo el proyecto mediante el espacio para \textbf{Wiki}.
\paragraph{}
Además permite la sincronización de otros servicios afines al proyecto como PivotalTracker.
\subsection{PivotalTracker}
La primera fase de toda metodología ágil en un proyecto de desarrollo se basa en el \emph{análisis} y la \emph{extracción de requisitos}. Estos requisitos son llamados \textbf{historias de usuario} y son el elemento base de PivotalTracker. 
\paragraph{}
PivotalTracker es una plataforma de organización de proyectos mediante tareas o items a completar. Cada historia de usuario normalmente es dividida en distintas tareas. Una vez creado un proyecto en esta plataforma y establecido los miembros comienza la asignación de tareas. Se establecen diferentes espacios o ambientes de trabajo que indican la prioridad de las tareas (\emph{Icebox}, \emph{current}, \emph{done}, etc). Con la creación de cada tarea viene la estimación del tiempo de trabajo de la misma y a mayor valor de estimación más miembros la tendrán asignada. Una vez finalizada la tarea es necesaria la validación de la misma por el resto del equipo. De esta manera está asegurado el correcto desarrollo del proyecto.
\subsection{Slack}
Slack es una plataforma de comunicación destinada a grandes proyectos. Se organiza mediante \textbf{canales} y permite el intercambio de ficheros, información y mucho más a través de \textbf{chat}. Además ofrece la posibilidad de vincular cada canal a los servicios utilizados en el proyecto como GitHub y PivotalTracker por lo que cada acción y avance quedará reflejado y notificado a los miembros del equipo.
Se trata de una herramienta muy útil para el trabajo en remoto y como \emph{historial de proyecto}.
\section{Contenidos}
En esta sección se enuncian los contenidos y la organización de la información en esta memoria. A saber:
\begin{itemize}
\item \textbf{Capítulo 3: } en este capítulo se ha pretendido presentar la motivación de realizar este proyecto, la metodología que se ha llevado a cabo y el plan de trabajo que se ha desarrollado a lo largo del mismo.
\item \textbf{Capítulo 4: } en él se detalla el proceso de diseño y desarrollo. Se ha organizado en función de los prototipos de los que consta este proyecto.
\item \textbf{Capítulo 5: } se presentan las pruebas de validación realizadas. Exponiendo su planteamiento, diseño, proceso y análisis.
\item \textbf{Capítulo 6: } en él se describen las conclusiones extraídas una vez finalizado el proyecto y a la luz de los resultados obtenidos.
\item \textbf{Capítulo 7: } aquí se detalla la bibliografía del proyecto. Engloba sitios oficiales, tutoriales, documentación de APIs usadas y la propia documentación del mismo.
\item \textbf{Apéndices: } esta apartado está compuesto por cuatro capítulos y su finalidad es servir de apoyo al lector de esta memoria.
\end{itemize}